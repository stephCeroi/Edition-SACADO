%!PS-Adobe-2.0
%%Creator: dvips(k) 5.996 Copyright 2016 Radical Eye Software
%%Title: ficheExoPS1_cor.dvi
%%CreationDate: Thu Nov 16 21:09:34 2017
%%Pages: 2
%%PageOrder: Ascend
%%BoundingBox: 0 0 612 792
%%DocumentFonts: Utopia-Regular Utopia-Bold Fourier-Math-Symbols
%%+ Fourier-Math-Letters-Italic Utopia-Italic
%%DocumentPaperSizes: Letter
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -Pdownload35 -o ficheExoPS1_cor.ps
%+ ficheExoPS1_cor.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2017.11.16:2109
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 919 2014-05-19 18:42:47Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 919 2014-05-19 18:42:47Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not aload!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-func.pro 0 0
%% $Id: pst-func.pro 918 2014-05-19 12:32:37Z herbert $
%%
%% This is file `pst-func.pro',
%%
%% IMPORTANT NOTICE:
%%
%% Package `pst-func'
%%
%% Herbert Voss <hvoss@tug.org>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% DESCRIPTION:
%%   `pst-func' is a PSTricks package to plot special math functions
%%
%%
%% version 0.16 / 2014-05-07  Herbert Voss
%
/tx@FuncDict 100 dict def
tx@FuncDict begin
%
/eps1 1.0e-05 def
/eps2 1.0e-04 def
/eps8 1.0e-08 def
%
/PiHalf 1.57079632679489661925640 def
/CEuler 0.5772156649 def % Euler-Mascheroni constant
%
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/Pascal [
  [                   1                   ] % 0
  [                 1   1                 ] % 1
  [               1   2   1               ] % 2
  [             1   3   3   1             ] % 3
  [           1   4   6   4   1           ] % 4
  [         1   5  10  10   5   1         ] % 5
  [       1   6  15  20  15   6   1       ] % 6
  [     1   7  21  35  35  21   7   1     ] % 7
  [   1   8  28  56  70  56  28  8    1   ] % 8
  [ 1   9  36  84 126 126  84  36  9    1 ] % 9
] def
%
/GetBezierCoor { 				% t on stack
  10 dict begin					% hold all local
  /t ED
  /t1 1 t sub def				% t1=1-t
  /Coeff Pascal BezierType get def		% get the coefficients
    0 0						% initial values for x y
    BezierType -1 0 {				% BezierType,...,2,1,0
      /I ED					% I=BezierType,...,2,1,0
      /J BezierType I sub def			% J=0,1,2,...,BezierType
      /T t I exp Coeff J get mul def		% coeff(J)*t^I
      /T1 t1 J exp def				% t1^J  
      Points I dup add 1 add get		% y(2*I+1)
      T mul T1 mul add				% the y coordinate
      exch					% y x	
      Points I dup add get			% x(2*I)
      T mul T1 mul add				% the x coordinate
      exch					% x y	
    } for					% x y on stack
  end
} def

/BezierCurve { % on stack [ coors psk@plotpoints BezierType
%  10 dict begin
  /BezierType ED                        % 2,3,4,5,6,...
  1 exch div /epsilon ED                % step for Bezier =1/plotpoints
  ]                                     % [ yi xi ... y3 x3 y2 x2 y1 x1 y0 x0]
  ps@ReverseOrderOfPoints               % [y0 x0 y1 x1 ... yi xi]
  /Points ED 				% save Points array
  epsilon GetBezierCoor 		% next Bezier point
  Points 0 get Points 1 get 		% starting point
  ArrowA lineto 
  epsilon epsilon 1 epsilon sub { % on stack is the loop variable
    GetBezierCoor lineto 
  } for 
  1 epsilon sub GetBezierCoor  
  1 GetBezierCoor  
  ArrowB lineto moveto
%  end
} def

/Bernstein { % on stack tStart tEnd plotpoints i n
  12 dict begin				% hold all local
  /envelope ED				% plot envelope?
  /n ED 
  /i ED
  /ni n i sub def  
  /epsilon ED				% step=1/plotpoints
  /tEnd ED
  /tStart ED
%
% B_{i,n}(t)=\binom{n}{i}t^i(1-t)^{n-i}      (Bernstein)
% f_n(x)=\frac{1}{\sqrt{\pi n\cdot x(1-x)}}  (envelope)
%
  n i MoverN /noveri ED			% \binom{n}{i}
  [					% for the array of points
  tStart epsilon tEnd {
    dup dup /t ED			% leave one on stack
    neg 1 add /t1 ED			% t1=1-t
    envelope 
      { t t1 mul 4 mul PiHalf mul n mul sqrt 1 exch Div }	% envelope
      { noveri t i exp mul t1 ni exp mul } ifelse 	% t f(t)
    ScreenCoor				% convert to screen coor
  } for
  end
  false /Lineto /lineto load def Line
} def
%
/Si { % integral sin from 0 to x (arg on stack)
  /arg exch def
  /Sum arg def
  /sign -1 def
  /index 3 def
  { 
    arg index exp index div index factorial div sign mul 
    dup abs eps8 lt { pop exit } if 
    Sum add /Sum exch def
    /sign sign neg def
    /index index 2 add def
  } loop
  Sum
} def
/si { % integral sin from x to infty -> si(x)=Si(x)-pi/2
  Si PiHalf sub
} def
/Ci { % integral cosin from x to infty (arg on stack)
  abs /arg exch def
  arg 0 eq { 0 } { 
    /argExp 1 def
    /fact 1 def
    /Sum CEuler arg ln add def
    /sign -1 def
    /index 2 def
    { 
      /argExp argExp arg arg mul mul def
      /fact fact index 1 sub index mul mul def
      argExp index div fact div sign mul 
      dup abs exch Sum add /Sum exch def
      eps8 lt { exit } if
      /sign sign neg def
      /index index 2 add def
    } loop
    Sum
  } ifelse
} def
/ci { % integral cosin from x to infty -> ci(x)=-Ci(x)+ln(x)+CEuler
  dup Ci neg exch abs ln add CEuler add
} def
%
/MaxIter 255 def
/func { coeff Derivation FuncValue } def
/func' { coeff Derivation 1 add FuncValue } def
/func'' { coeff Derivation 2 add FuncValue } def
%
/NewtonMehrfach {% the start value must be on top of the stack
  /Nx exch def 
  /Iter 0 def
  {
    /Iter Iter 1 add def
    Nx func /F exch def % f(Nx)
    F abs eps2 lt { exit } if
    Nx func' /FS exch def % f'(Nx) 
    FS 0 eq { /FS 1.0e-06 def } if
    Nx func'' /F2S exch def % f''(Nx)
    1.0 1.0 F F2S mul FS dup mul div sub div /J exch def
    J F mul FS div /Diff exch def 
    /Nx Nx Diff sub def
    Diff abs eps1 lt Iter MaxIter gt or { exit } if 
  } loop 
  Nx % the returned value ist the zero point
} def

/Steffensen {% the start value must be on top of the stack
  /y0 exch def % the start value
  /Iter 0 def   /MaxIter 200 def
  { pstack
    y0 func /F exch def
    F abs eps2 lt { exit } if
    y0 F sub /Phi exch def
    Phi func /F2 exch def
    F2 abs eps2 le { exit }{
      Phi y0 sub dup mul Phi F2 sub 2 Phi mul sub y0 add Div /Diff exch def
      y0 Diff sub /y0 exch def
      Diff abs eps1 le { exit } if
    } ifelse
    /Iter Iter 1 add def
    Iter MaxIter gt { exit } if
  } loop
  y0 28 mul % the returned value ist the zero point
  0  
  3 0 360 arc gsave 0 0 1 setrgbcolor fill grestore 1 setlinewidth stroke
} def 
%
/Horner {% x [coeff] must be on top of the stack
  aload length
  dup 2 add -1 roll
  exch 1 sub {
    dup 4 1 roll
    mul add exch
  } repeat
  pop % the y value is on top of the stack
} def
%
/FuncValue {% x [coeff] Derivation must be on top of the stack
  {
    aload 			% a0 a1 a2 ... a(n-1) [array]
    length                      % a0 a1 a2 ... a(n-1) n
    1 sub /grad exch def        % a0 a1 a2 ... a(n-1) 
    grad -1 1 {                 % for n=grad step -1 until 1
      /n exch def               % Laufvariable speichern
      n                         % a0 a1 a2 ... a(n-1) n
      mul                       % a0 a1 a2 ... a(n-1)*n 
      grad 1 add                % a0 a1 a2 ... a(n-1)*n grad+1 
      1 roll                    % an*na0 a1 a2 ... a(n-2)
    } for
    pop                         % loesche a0
    grad array astore           % [ a1 a2 ... a(n-2)]
  } repeat
  Horner
} def
%
/FindZeros { % dxN dxZ must be on top of the stack (x0..x1 the intervall) => []
  12 dict begin 
  /dxZ exch def /dxN exch def
  /pstZeros [] def 
  x0 dxZ x1 { % suche Nullstellen
    /xWert exch def
    xWert NewtonMehrfach 
    %xWert Steffensen 
    /xNull exch def 
    pstZeros aload length /Laenge exch def % now test if value is a new one
    Laenge 0 eq 
      { xNull 1 }
      { /newZero true def
        Laenge {
	  xNull sub abs dxN lt { /newZero false def } if
        } repeat
	pstZeros aload pop
        newZero { xNull Laenge 1 add } { Laenge } ifelse } ifelse
    array astore 
    /pstZeros exch def
  } for
  pstZeros  % the end array is now on the stack
  end
} def
%
/Simpson { % on stack must be a b M   --- simple version ---
% /SFunc must be defined 
  /M ED /b ED /a ED
  /h b a sub M 2 mul div def
  /s1 0 def
  /s2 0 def
  1 1 M {
    /k exch def
    /x k 2 mul 1 sub h mul a add def
    /s1 s1 x SFunc add def
  } for
  1 1 M 1 sub {
    /k exch def
    /x k 2 mul h mul a add def
    /s2 s2 x SFunc add def
  } for
  /I a SFunc b SFunc add s1 4 mul add s2 2 mul add 3 div h mul def
} def
%
/LogGamma { 5 dict begin	% z on stack
  /z ED
  /sum 0 def
  /k 1 def
  {
    z k div dup 1 add ln sub dup
    abs eps8 lt { pop exit } if
    sum add /sum exch def
    /k k 1 add def
  } loop
  sum z ln sub CEuler z mul sub
  end 
} def
%
/ChebyshevT { 5 dict begin	% z on stack
  /xtmp exch def
  /n exch def
  0 0 1 n .5 mul floor {
     /k exch def
     xtmp xtmp mul 1 sub k exp
     xtmp n 2 k mul sub exp mul
     n 2 k mul MoverN mul
     add
  } for
  end
} def
%
/ChebyshevU {5 dict begin	% z on stack
  /xtmp exch def
  /n exch def
  0 0 1 n .5 mul floor {
    /k exch def
    xtmp xtmp mul 1 sub k exp
    xtmp n 2 k mul sub exp mul
    n 1 add 2 k mul 1 add MoverN mul
    add
  } for
  end
} def
%
/vasicek{           %density=sqrt((1-R2)/R2)*exp(1/2*(norminv(x)2 - (1/sqrt(R2)*((sqrt(1-R2)*norminv(x)-norminv(pd)))2))
  2 dict begin
  /pd where { pop }{ /pd 0.22 def } ifelse    % element of (0,1) probability of default of portfolio  
  /R2 where { pop }{ /R2 0.11 def } ifelse    % element of (0,1) R_Squared of portfolio
  dup                 % x   x
  norminv             % x   norminv(x)
  dup mul             % x   norminv(x)^2
  exch                % norminv(x)2   x
  norminv             % norminv(x)2   norminv(x)
  1 R2 sub sqrt mul   % norminv(x)2   sqrt(1-R2)*norminv(x)
  pd norminv sub      % norminv(x)2   sqrt(1-R2)*norminv(x)-norminv(pd)
  R2 sqrt div         % norminv(x)2   1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd))
  dup mul             % norminv(x)2  (1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2
  sub                 % norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2
  2 div               % 1/2*(norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2)
  ENeperian exch exp  % exp(1/2*(norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2)
  1 R2 sub            % exp(1/2*(norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2)   1-R2
  R2 div              % exp(1/2*(norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2)   (1-R2)/R2
  sqrt                % exp(1/2*(norminv(x)2 -(1/sqrt(R2)*(sqrt(1-R2)*norminv(x)-norminv(pd)))2)   sqrt((1-R2)/R2)
  mul                 % sqrt((1-R2)/R2)*exp(1/2*(norminv(x)2 - (1/sqrt(R2)*((sqrt(1-R2)*norminv(x)-norminv(pd)))2))
  end
} def
%end{vasicek density}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def
%
end

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfH{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def} bind
def

 /pgfV{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto } bind
def} bind def

 /pgfA{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1 add
def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div
2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index 14
index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke 4
-1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1
roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx exch
def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade {pgfR}
def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx pgfstartx
sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb exch def }bind
def

 /pgfR2{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfR{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1 add
def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def /pgfcircy
pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe pgfstartx
8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty 8 index
pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx sub pgfdiff
div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def 2 index 6
index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index 6 index
sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff { 3 index
3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1 roll 4 index
add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy
pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark exch
pop }bind def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore newpath}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore
newpath}bind def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def
/pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind
def}bind def /pgffoa 1 def /pgfsoa 1 def end

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC7775D014891054D978CDA
2123ABEA1F56B7AE95ACBFB66602930C7FF181D407919EE24F9822ACEB90CDE2
8600399C4B6A20B9F9372AE5FF89509FC2DD0A41FF090A6554331231DF4C7487
1AE978282A9D1CD19D8BC9A2C60B4013973946C9961828EABE87D4EFA0BD65C6
86674692C0F27E9FAF66DC1195124A60A6E5F01BF2C6D78355FB7575C229866F
C1AB1434BE0F4861EC8F64AE46D40D52EAC802878FF064922470D50F2A18FE57
DE5237FB22C8424FF3CC5990A998A735C12B31FC7F5E6CE9C732AAA4AE3F2C72
C23DD8504C426F0258ADB1585D75CFE278C1CD4E699553715048D27CC0A4E0DE
FDBA01DDEF496F6DE0DD44001E2F1363A9B1A38719B53E70C814D0FC7F5D069E
C95994EA648AB4D100B6B2DA0E1594AB8CC867B772253A7C92050AEDE8F8E58E
2AF48F64A090AE8D456458835F196A930F7E51B1E22FCA52B12375B2DA1EB4C8
19A28226AFD8F3E04598F519B32EEA410CA5C653EB9FDAA0CA007F8DD54B61F0
F8DF83A7B4BD041661945091BDCE083424A47790C81D990013ACC1763260E9AC
E361D63457087101F7BF2358A06084859C632C8DE35FADC38FFCD02EC1160CAE
5A6D87E2112C48DF124951653D19B04EEA5CFD0D994059D2B412EA2767BB5867
F44610C81FFE049D199AF9F5B2786D5EB2431E778C6E8A492379CD73BD7A2E0C
CB6634DE71F20FCD1939F2A0A02FEA9FAFC4A3C788958195DB48A6EA8666FF25
4A83839F08E6B37E6E55F27832DDA15B7592C06FA60FF1C751CC1E402911CAB4
9534A03AD5A6ECBBDE7FC6E3CF2FBDA627F286079D9FEB4F32796B8CC631E5BE
FC2A4098E742531892BB3AAC17AE5CAD90A54827B97B32E0782DD1D4D1EE1925
CAE38446B04E4A217B1E957C7F079E0DFC9F87A6BB14D55911F33784C0D0F9F6
E2F5AEADB7552A31896A660AE2E413C1D7F155F64208D863BFC85A56A2C40A54
A259EC0E3C0FC8EA9EA8899D2B3EAA020D5EFEED9DEFF3B11F29A2EE8212CD77
2399248B4F91EAC215F66798915C7A1294BE6254F9C180B4DF8A79EE13634A70
CF52E3FB1EA1379E95773BAB3ED617BF4A6983231DCE069AEBA3D30C7F68CB69
A8DCD6D600ECAFAE9365148A3975650CF0409B4471853710FF2B2B8036BFA070
AD92709991B1EEE859A2E5B7D94FAF688A99FE1AD1155671E35C0A0CCCF9E31E
936B946617784C4DF2A77D8F9AD4A83D051519AE81AD4CA7BBF7CD4BD64C07C6
74FE97C70656356C6F0C0D960075B603638112741E050221AD7FB257B1A7B30A
59B619619AC38CC86516B9C229EB4E62793F82F0743F6AA5BF0CD33E24FEF0AE
2A11F530C3C25522EC3ABD5030C68DB2A5A5DA3DB7A011EBDAEEAA636E21803F
D4B383FEC35D9C5A9AF7F40BC7A735A55B99F998C318A8FE36E203EA6D6A3CDF
C195C99A1E758C644ED6BD661F2A8E7789333EB2C525D9411824BB0A68F26579
17A7C122F8F3D7E30950E5BB6B771DB0BB2D0B9A366D8E93741A4C1C2854E3EB
596B08954C0E694A20846A32154D39CB69C8AFB8082C11321DCC98C1DCA5AC84
DC6AAA44BAAC095EF9356E4F9E28175FB1C7D4EBF39E0F8C712C2EC45E4F1731
3FFBCD902C53053C251DB0C171028BEDB61C625FD160E557CB08B25FFBFBD4A9
78F7F260A037A1E6007952C5322E02997CED4A06891A8B576B2B224A97D8A0AE
FD7FAAA7A026FD33BED2B2913FABBEEBE48381BD10AB444EB36FEFB4BBC6FCD6
DA55C6B201444418493C3E06B3BB05872F83679CBABE4996D7B0EEE93D0E443C
F53375CF0B32619E0E65A4037FC1CE9D0A9F4B21736FE40A4B58083F708A77EC
BB90C048133330D1FB6EA502654E003AC9E8BC90572625BCBFAF28A556C7F0EC
078B8996B3E88EDCE2DCE82AF728AC7C0AD45242A8429747ABA09AC8171407FA
5BDE04EC25B222AF1F24662ACC6C2D251038A8CCF3599346F2EEE78166459746
BBCA2774F277300D03253DA06121762C337FDBCA1CD26B86861828ED6A02B1AB
FC41E5C04B40FC281F6F4B4A86855063934C57240DF8F67B12BD2DC8B1EDC849
91BC0D3213F60CEE8D52BAE71F9CDF88361E23740B6BCA5C7794420B43FC862C
05786E4B9BB5B381820A39858CC4CD718151C53D22399540CAD8447E651688FE
1B8EB84D58140C2CDB18FDD0A629F963095EA8C2953180A91008FE54E68529FF
BCEDCFD94F95B195119EEAA6EA1FB37AA1507A477FCC63CC8D0BBFCF33E5B47D
81EED29F7F7CE6CCE12D83B6271FE38DB3B8249552FF9A88ACE08075EF4B7B4F
E481767605D56B6C69AD3D4A3A43C7F5CC9E9137B95845BFD4A6BDA3D5C55971
AB1701E412522CFA6C90CAE4E4C26E57031564FA0366DE1D5C9BEBD2BD469C32
6B7C03D4703A071D3C190412B536DF4A064C15BBDF52DE1E42A1521DE821B0A2
FC1163200D0F18D3CC302E4E863FE13D6257DF7AEF4F19E014E4B8D39E78CAF2
04E237969783120829678BEE68D14BCCB9D5DC3BEF9C7F0592351D6FE24A57A1
88D0E3C679E373FA58D209095BE9E350A8AA982FBCF6980AD8CDDA23E8009FCC
5DC196F8B7A3C16FC9BA86D4165315DCF3FD6459170BB00115A1C8912E3B0D24
BA1C1EEF6CB0B15125CD1F4D807F7DE678CDC8A130D2200D707AC29EB7A2929F
13FB467250D201467CD101A144B40D4D871D7F96737C6AC561016BD8EBFAC490
0B3F5F28745075DEC90A4CB28AD257D15B1C247C98FAA581A29219434D05B0B0
101C2F371630C433FBC17F04482CC44B4D64710AD9B605F7DA435D1C95C59AA8
0486A8CAF0DFD03BC094C5A97494A42E4FC5A3F3FE87EF0FD931FBC95992607C
9AE605FBBA07B5830A1BFE7A2F0C8917A6B7B9A85C149D4778034A2CB2CC7462
05AECECFB6EF2B810ABDDDFCB93E6C4B30E138EB5D23D8EE1B50C32B6BD9FAE2
BEC59D678580023E97BCAB0958C6075F9C61F43EBA5A662995B77A890C87E21B
415FDE78634543D6514EF35442B053AE5C438F49A3B40B9C1F8C6C9312D713E3
3D8C93D248753F91781A468F1E1BF31D0750D09218205BE7874D3D1DFE3515DB
1B2049F5ADA01F73A09A5F4CA59C6BA794999A342078A3712FBB29CF0296F739
B3306505EA4FE1873185B4D4AB92C16C3C47197526FBC56BCD0353714B05F916
8BA831CCF5233F205E185DEB4D4497618D85580C843B00C1B791E42472041C57
5AF0F179E8CA9DCA1FB71E9D0B1BA8D526E8D615308E5F4B7498F7B89AF74D39
C15D5E99FAF90989A775C338166E1322D5107325266CD1C58BD738A1EC2A6B35
E8A9DE3EB87AE86DF86053C13D34B4A0D9A794295980A3AC0B2865D54AA52346
877976C122740BD78EBAAF03B0CF906BC1C234FBC08895D04AF8014815C3B827
A64BC14A177F200389C837888B67FEF0B00A0BE96EC603C48A7C98195AFD0888
A53DD5DD3D7F98F31964091976723CDAC21F5A95058B49A35178212547E7871D
A1EE731CB99C18CD5E1BA0742B46E00A4EA9CE6156337699AEB3705F125F62AF
90BB985BEB9DCC5E46B981694068A3C6151AA72FE8C00BB5CBC71FE2F900C92E
6405D7DD2EDADC05F0BFD5608EF6CB732ED31BF812A6D83A68683D07E37FEEDA
3CBF621495461F3FF2EFF20DCC4FE58DB7996EE710A6E48084B963C3E0FB216D
6706337662B9435DEEA2BC8E8EC1D135B6E8B903BF0799BDAA3C08BFEB98926C
1CF73D1CB7518F204732B5003F5D1DF8B0588774E935385104C7C0730BDD4A2A
0A56807785BE0525A5FC03799CDFEE8095FA04606E14818DB6CF57EE7F9DC626
9AB69F495A99B93FA00F62F7A57B59364BD9A068E597D00057DF42E2A7451675
B8F0DEBF8478B4A1CD2A33D7314E18E98E253A9C6CC536E927F4A4AADBB46704
69FDEA0CEB1E16ABCE86C6EDC4348EBA172A5E8EF0422F3340A01626157E9EFB
C0B63F34535085A691558234C56960447380AF8E942C0A839403EADAC7EA4401
87C8FE252715CCBD5711618A61D39A12F5153341467295852D683A1A6A43FBD8
DC8ABB13FBB818DBD0CFB8C204E6B8443669944056FA8B718120E27014B17408
98746A333BFD6593A98EB99888DF64AA65C0AB3D92AFE297E5A3C39020E0FFA0
444E75E426F8EC37092ED0A93F85B075FB4A3C0642C54C65677F0878978C821D
33E05E8272B8B26513917B64E296D4E22B7DEEE932B2013CB324649C50017C6B
87F9890C270D5C81BDA1A9E39080DABD28203E2A3915AA5CB5748E1243084ECD
3CFE3F21BF1C731B584D5A3508FE86FE9ACC6130A67D91562D0608139F298CD3
2219A49089612BC578D3C0CB13B2120408D14B66B5CE1ED0AD2CC71B77875CAB
7C4E65B5D627D9F3CB0E7863E79A95347529021C923B55FE0C28D5228C29E5E5
B61343C73C44EC877FC946E9A9F8E0D07627D9D89CBC802B78EF0C41B98D129B
6D8BFA8DFC4CD4AEC967043DBCCB55C9C030430301E1AE9D5DC082F340B62D5A
C2E973A03F642F5DE5481F39932A641B00C56A6A6FA7703F9A5FB3EDF2203133
0E2850347AE583D180C5BFEEEF3B7BDCBB8DE5BEC240F24A4F88A623BD35418A
3FCE2AAF594FAFA0443330559DD936B2CD7601BD40623067E7E16CEA45C5C034
8BD4D9767A6AA128E365ECAE45A1AD9F50881E6B32CEBA12A285A656F047B164
7AD018CA5CDFE8BEC0AE986408CCB7C375321C5B5422DC7897E3FD01EA0A83C4
3FF78A1629926169F4AECFB0BC29C36A255F315990E2FDC07E0F4C5C5F208742
A9225CD059B509F0B951ABA4D2861D0A93C6419A6B9B91525E7538029745E21B
741B5BEDEE368CA8B63B4B920E187FF3594BDCCAF80BE718ED5951A3093A784A
146ADEA4A23224BDDCE6DB52B7BF41CDB0A2CF80474EEBD3B4B84F652471375B
1A38EA2FBDCB2AF1CB6735D3C2DAB8A8B329133FC43847FB20E3887F51791531
AD0169BFE402114BABBDF2327A8FEC2A6E130AC470C8F96978C1F25F19AD2CF0
861ADD632F10FA28D50D9B6D7AB78F443AEFA6019C7D7A44F8CCA456056C518B
5F7BCA4E54FA49B0444E7C05F932927A0AF6F28122ECCBC84367AC7F724238D0
1E884D9F04CB6098B0BD07C1A9DC483E713F8D68C9FEA8E1EF4F3260FDCEC2B6
1161238691B2E31986D385BA0DCD0C6AFCECA423C805F093D468DAEE31883DB1
D677859BE21A2503CB2528CC0C881C582F4FFD2BA18EF531DE098769DE520132
824E7421C17A428D9726D99E2108E0CD98602BE9D95480C91514A079C0157057
4EAC7E17F53081B66089B32040A63A6933DF3A2AFD5F8DC4CDC30E377B78459B
2DB4B747BC136CEDA7D7E39BFCCBB5532A4F584E7005B21359C35DAB60DC793D
9C260FA88819131F364133C8465D8B51D8142B0C866367FDA0F401034AA3CDD6
C22B1931004EBF34BBC2FC5095EB787B17C4355E5CE34D20D24392D3A3827038
A6BAB1BF87C859A28D3E21C11894F085AEA94441AC7CC541D6372B6F418A1528
BAE9EF92F067F255C440F4CF4C9F6D97A192426730E1A433BE9CA9C20B62EF8C
DCDD0C2C9E238CFA5229C6CA9CB9F513EE814AF4F9886D831AA514A2E3EFEDE1
509154A47B6B18BF0397FB6D456DD0F3DB2EF8D42ABD04A06D159862B0AB6E56
2F531D399F87FA4E224F7FF96B4269F936D2A334CF8838597F809CA8C8175627
4E544959B43E5893CF31900167B61633307BE59289725D1FE40BC8A926EBB78A
52BB5B407A9A653A4F75C606F5C9317680A1327DB372BCF6E110943A34F7D5F2
3BBBF34029D1B31944413E6D07229DE6DFCA062CCD93112678869F9BBD41BD3F
1E90B8C3F56A8738208FC98B80B7E29E11785992E9E74A5234DCDBD02621AC12
B84FAF35CD8A080E0E1B6A13EB6527BB7C375828692937B11FA748F0B81ED188
28F2FBEB8307FA7621237F5E84C46AF67A0A3FC6ED9C116ABC2B3A537DBC36DA
6EF5A42E2684262BD1C6C279672B00A179A125272087D1106B5BD8AA8D24AA85
5901C28B72DAD6AA23F18EEAC5CB30DD367C3606D8E5CFA7A2678E64395E7896
365ABF47FBB3DD20C744D404ED310E37BD3838708EB224BA8530716A7324C83E
86E22409426408267FEFCD4B77DB1D9AE1570BDDFE895C0717E2271C58E15A12
42DD613FB4D3FDE9BE835A01FD8F30E96A45105B9738CEB68E8766314113DDBA
DB6E56F7B4B38BE0A5C8B360F095D8BA068A8D37C9BE16947EC364D5D3437A03
AEB4291F5EEA4D26E27D5C1EC21BD233CE7E801178FB453C61CBD5B93019A8F9
6E2E1F02AD42918C8C67320F69B122282F6023AD0124C1C996F0071B5D1D8C53
8660163EFA573C58F64560F50B146EF2FEA475AEC4390D8291B01E1EA342E325
5D9F5B6BAA7B9CF1B3A17A00ED1C1057FB5F50D8A3D50995417386EDFFDAB7E6
BD5B6739F8FC387EE32386CCFD2D718595958A47E3D471FD51D4E048ADBFED8C
929ED0BEEBE9E2BB72A5CF8794E69B146838907F9EB5901BF1754C5FD1B4E906
DCAAC1C15EF356997A12C2DACBFD9BA0526D38D1F94E58532D02C583DC2539BF
754779796CFFF55D0895FAD53C671566B9CB4C32BF24D208216394F39CBCA281
1226C51E6136B95A2DB43452F5FD4EAFE30F8D89471FC067CDE5B7DABB4F13C0
235CEE364ED35373A1D0BA009C5A0DF425F0F8F0992FCB2343AD613C0FC70881
5E3EC4EE3C064A8F5957280E7BBC372737B3DB0D01EB5D8334D34EC700F5F081
20B8B5EADD62900AD84C97A889506C67D01B97392FA76D167DFD3C571844D02F
04EA467D3B4AF9FE320D38D83D859C06ACEA657DD00BEA95C8604D5986CA09DA
F91025514989D6F14D32E9638736E33D367D772C04243C3D00DA2CD82AF5BA81
1F495C1928CBC84B7FA0DC20C1D5F5527649564A052EDA61C77D4130BE3FE2BC
9CD49F901ADAC88C23F850FF698A1E383942D0F4BF68483C3D257109D334F2C8
4EA47A1335CA1AD3F0F63631E2C3E7B3F59AF7377DD8F3CC73CA87371AEDC277
1321F8DF41D8B53FB0C0768C636A0B57ABDE5E61CBE2F070C5A12D6887639404
95962D6AC49F319733418E2837B0196FF046F92617DA7F0F7BBCAEE5265EF536
CA71E3A47F3BA5483326E90448387DC65F29828D7DC958112BCA2E4972524E93
F57B276B7F05CC9DB849CB9EB12C137C8E65B349B69EED368CFA2F39E2BF7BAD
F84055203FBA27B23AA5CFE926BD4891AA9A09552C199E38C019EFAACA336C3C
0914AB53A3062167ED02D8D4A0D9C5B42593779515593C1E7C1360A784AF0AFB
C33E67A66C9F5348576F4593A1DD7AFD57C667F00D1EFFB9F647293214462653
55FBF2F46A25FBF274F37EB49E9728D6C7E564DD2D471F47B2252367EFD9F775
143680C5829098F87D7BAF534E49E3E103D4CBFDD3DE32F37CB3D8818F5E667F
8DC08E3751B4105CFB1B012509FCB6B006ED7F59A091B17A3FB6C21BF79B661D
337688095FF7A7B7A8B1774C43DD0518B74FE84406C547C4DE1CF470D7FD4E3F
5718DED88929C6A2702D4A161864FAA258CC6BD5A3497BDD0E29E3F031D0264B
80AFC3B24AE681DA1E7C5D9345AF4BE80773B39845B5FCE7765EFE6625B1D5D5
2AAE1406BF9CBF179E8A70084187528B0990DD3CD0D1ED40F713A1CDB72FB31A
5488265E57D756370EAC786FD51132D605E7319E1BDDC1DE381373D3675B4074
744690685EEE573934F0D934F31E44B111019B45293D4CE07AA49F0A101BE27C
691017520F668B7F27C6B2B13BF92AECBBC14DF4BA154569082919F7CBD09AB6
EEE998B2502A936A8AB269961106A13C44123D05F1774A9872EBFAD8FD1D0AD9
C7ED1DD3F7592821C77978D91B0C7FD4F728929B5B5885CE48E38B27C4D725B2
EBEB57C2E740F5B99AA4DFA9BCFA45AF125304413F3A7E62F956159FBC8619C4
CB217C154FB15E9E9A35108DE9229FA12E8D21101CF22E007F972B81DDA5283E
12E4183CDB8FE24FE263FA163CF63523F39F56ADF73C37AF77F551DC5B9A572F
E37FC732934270702C9E342448E333C09D2B7C6E212AE6DFA197DA6CAC681403
7ACBC46A20A5C98EDAEFC16FC31EBE59B11D3061CA040E4CEF9CE3AD30D1B253
9884A1B726C4228D3182A74B4230A01EE44EF4B83D9A5182BF284385DE8E2DB8
C603DA74AA80EA9A3E4EFE5B16E4A9255047659B86235A2F526F48307431867E
C3EF7C9B37AB41825456ABF8AEFB7D59BB202175560AE08588CCF62A2972B74B
C0D111ED3C7B54587B0EDF6AB622BA792194727293A9F2C1BD1ED08C01E66619
2930CE1531F365AD62BB8868EC99B0F5292E668E335AB7E673222E097B599345
B53383AA2FFAC32FEE06340147CCC49CC886710E368594BFFC04C7F2DDC1B19A
C7CB8174C3B0075FD5AB341815D40B5BF041E04E084BBACB284E3D1F7A1D9EB1
B4871A83DD306A300D60747718F3413172E5D24245A80B6EA8EC93511A37CD0C
8A8B34484F14D08A83F35F04915D9D26A8144C7D57622B568DF6B572D2BCA16F
D95051DD56BA6FE010ABE6439C03CC5F7A33F626C26582A1CCB952ED9E456636
AACBC7FAF9754ADF5D3023EE78F57326E70D0FB66ACFAC35B2E0F46EB28C623C
980820FA42D6D203117A19D419584DC09C58B9EC29C98457290131826CAAA963
5A1EF2CD007E7D9AB4D33D2751503D159D058B4C5C9808404D479489FD86EBE8
0C8B0B107ECD247C43B9ECBB9678C3418DED87941DDAD3416FF454B6165E02C0
EF750E8C8CB171077B90D245C1B975CA3D680C0501DBB158822E0487BC3E890C
03CE4CA7A41DFFC71B9654C0CD0E0207616B11424CAEE2F65A8427E7F1050B85
FC17010A1FC4528C595955A74035264C50C8D342D537E9284BDBC06831E4155B
1B8434E0A65DCDAD02B843B26C759CD3AD0DBCF09DFECD1F29BA0B6A9031F4BA
FFB38F7DA804FFDD04280513F5DE90CCF477192AF6D6F2315316A8ED10E5FD28
A44E5F8567CAC651681C8A22DBED29AD055701F857D143BF662F002679EAEE38
1C726DD8FEAEAD8389D1ABB6E415DFF0BF10A839B2A9E2E525FF351CE9FE5850
1D425BD11808F268D3CCF20E7133C92A71D2E2380125D05BD53A4F60A67B93CB
6298F9EE660D4C62C19E602D59050686D701CFBB51783EC87FF763A214E9EFCD
E3B4560990BAABA4FED1A48D45A4292FE39C613ECD4AF0ADE61D639FA2883616
D31854939B9BE79C9A9655567AEF67B112125CFC5B5B822741EBE7F76083D5F7
23F617D40D230999C906F97AE33E89F2E15C26FB50FD3166875D4F836CD706DE
BCF48172884790D1F605B5102297E197FB8C8389E9097085F802CDEE67CDC9FE
E40431F4006B90C7C966B8EA949989491D813BEF7D8DADFF4E0BCF5D5152D45E
A327F0CB185D06751DD3914D63F5634677ECF906231EABCB2D78109371777A00
0015A78C82E7C2F830C192574CA8D5272F7AF8AC480A70B537AC1E510E2DFCE6
A6DE2F3F6352BCBEF116F7AF918CE84F3E11C78D95A781BA97630804E59C58F8
AC39EF881EBD67227A819952165B4B0722B3C830AA2D98339DE420CE9EFE9330
926A2BD207725B7335DD0BEC7CF4718DD267DC210CE8292EDC264DCEA2738F70
8506C4D010430E7ADA891F6B6C2E841E5049C42B02C62C1C62A3458565FE0D23
62161F3D29D1DC2601E9462DF4721EB4552DEF68371D04C100F3180BC4B69F49
088A9BE8F5FA224DB91C4B134528B4984FBCA7631891759DBC559F69960B850A
764ADDFBAF8CCA05967CC58A0CE61B6A01BA78084AA2BA9AE311D8F33DCA9771
9717C391626FD15AF36F320E2CD59ED278A68AF5403766065473B4319392DD77
132C77651ABB4ACD1636AD5C70ACD8D35AFACFCA851396A5C9DB466EAC688A25
29A38153E830766BAFEDC399CC8B7DB51842270FAB222A517C6353E9C5827A77
DB58588E19FFD28EDE20586809652DF6AB4A363D62DAA866CFD1646784937303
3BA32D6008BB2F3296477311BC556F43AEDEA439C95A2D5CEE2F4047A9CC27D0
E38B5C51A38A46CFAF8921991960F28438289F7914432176A0B384915D275CEA
5B78ED3B2387B93E2C8DC6A9D89B449A81646B6E717CE9A1DAE0EC6BA5CDD122
C1158544FF2E715CEFEE6DAF00B2DF9C73245DBCE63625854032598E41F7EECE
04DD1B2CA15209EA6C18E3AA9DCEB4E5E3C17FDFE1FD7E28948FDB59CA7434A5
C6A5DB52992DE617DE48BAA35DA0BE0463CF2FBA48D153E55C7C05D2FCB11F3D
123C7DB508294B80C3B965193EEE8361FF6910C1DCAF96B5CDB0B63130E0AD60
718EDA3A2477EE6E5164985E2A941BD27BCC91844C79EC352F08DD12058A6BF1
4FE1314AF84DF19A62E23446FDCB2296E416ABDBA0399BD4D5CA41E10CFF5C14
B0537142A02A0DB2AE2C01704ACCA9EE4A4104F9C00DAEF00E35F04364A24645
2F38453505F74E7A70094FA94B6323B2675FBCC35FEC320A30D731BAF48EB5A2
2CF0F067F2AB473D4EAA8FA0CA8032B72C34ED3D386E70DC6D874CB916C779D3
536A5171289E0B46DFB4230B0E93BE8992CCD70823D607E45E544AD63BE79D2E
9B4A0E596D3572898E5E51A456D1C2635C21AFA286867A2799F1C34995A30258
282BCB5B02E38BFB36CBC06FD9269FC73194A250C078C774561233C3E5964ADC
98CEE2A1576C05EA3E8BE4131E487F23E35745033A81E61A2BE1661600525CFE
88A26617CA6F5840F824236037C83A764F29F6C6DF2BFDAA67BE0247C42A0E79
C6ED8344F45EF9830959696D33617426738917A380E9B996D3FDB1BBDFDBA21A
560A07EA1F67569F60D79596C252C27A1A9BBA2A37863ADB7995EAF9A09149A9
FDF67D4951E77BB0960E3A36BB87A6D6A789F002CF463769ED282719771EFF72
6D4F086889A921E5123CB67A3380163CDA2B2FF3260E53264E41F369D76372A0
46FF00D80D3B91BD6903FC79DF64663B53887859EE288BA6CE8FAB85AA0D5109
71DA4EFE663A99E64655033975C5EAFB95BE411BDF6D5C944BA72D8629E051C3
ADD3B2715528F48DA38E209DD4E548E5138830E9EF2F03F473C2C509BB9B2CCB
8B8BBA19CB1EB50DAD8DC926BE43D864F7110A7AFEC7A692DF626B8375C52689
A4650B96420AEA3FA457A2B52428631A6909737252622D485EE9CB6D2FBF9743
BC03C431BDD79636B85251D4DB9CC36197224A8A478E03EA8489EF99E742AC82
D9A687BF967382B63F20E5D85AF53C31B80C29051F5347489BF1331B89E5C835
CFAD4195024608513713B2F75BB802FC05336F8D5345F092DC73D7AD9990BFF9
B23138014A9B4B334922C58F94638135CC53810651D29A1451912F4A77639949
70008DDFA2ADAFC4E2DAE890CDEC2617792A923702A6AEAC174E1333495CD2C0
0F0659D9FA08099BDCC0C99BB754DCDF800E9D750730ED98A93BE91F9745A608
564DABAC8AEEED241C0762949B1AF292CD19E2070056C3470404AE9CAD174879
8A8D909206DA652F64E405F9960899738A6810A8A4C93B28C1F126C59931EBAD
3E49030BF707F6711D68CDEE4EEFB3687808DA0EA994DC152E58825CF6CA712F
D22B13ACE08EB4A2BFFB4C648A9DBDB123922B25CB8F4A5948C7B18DC54E3D60
B5EC8043ACBB4E3F40EE3C5B8B6C8686F0ACF1E8EABBC26BB2F762273692696B
62640A8DAB358DA04EC3E1274B2700941A6C8B3546808BAB7E601D031313EBAC
E267E3F3CBA4BFA791A352BE082DFA6BD414E69BBCBFB78BD03562DD5C3E2745
BD99358186FE7E20C386E13F82F120D71163C369917673D2A04F1825E54F715E
13B5F6588F7621C6645C89EA79D20D7B2334C5198D2995FAB8AEF56252279D21
FCA420C3D11A8EC5E54FE5972CA35E0D262C78B2B6E8F9E07AB64BA9866D7624
0022B466559C84B7FEEE9AFBDF56C501F630BA5060DB4C0179C30D7B07C6FA4B
DAB0CBC741BD0DCC34F3B73C5D7E6D32B5C41F537C47D495B8DFDE2DEB15CF58
838ED0E1D213A1D4B0958454412199F22D6AC709C3E49825D80D3120EEE04529
158C1C6F57BB8ABFB7BA3FAB86AB32A2CBFE45ADEE4305B45C7433A4FC053D7A
FCA6D3D2465E0239EB7680577016CB8CD88A066E131AD72098EE57CA2952B11A
B3EBF86844F310674B2747C4FD702BC6545FF3E3F1DC5CDDCBB117DAA439A6A4
C4B4AD0DB60856EF4640A77FCDF0F7AE41D11E7119356B8F914AAAD57A93A1E5
C3518FDF02738D5B98B2FF750ACE61182AD10776208E88C6B58D6C652F245326
322B9CC4A11F71342A976034F50DA5EA56B3EF3F2172A77D82D753E114146EC9
B8D894615DB038BAE6BFCDBEAE194444BB63D67CC2A11649470236D719FF61DA
9ED34CDE6635A453C7652B96FF80A09E46DEC36343BD638149EFC588EA293D71
60AA580F3AA9801E0D31014BF90ABE89F5DA45924A4A798E3B9949EF9121880D
A9FA2BE1F84D0C9530B5FAB6FEDDC4ECC9C1DF3A297155ACBF85B44CAFF7A04A
618CC231836F2193DB984FF8FBFD4DE9F1CB0CAFD2E7CDB17E4A9D4D372DAB56
438F1AB4C7F2E46B4ABAAB859F1D7FEE6090A569356684D3DF12909A0A704CA4
AE53271419E4F51DB474DEF29DAA36C9E5551647933538A60EE973E12807BA24
F16DC12C4F3B4CB98AB146AAEB3B5631C1CDD400C6DB8C81EF0776B18636FBE1
FBF1298F80536A27C686E5EFBF73F4A23E75CF246429763E555F6634F22ABCBA
5E76C697A8753CCEFE628ABA306538B0B91C5AFBB1DAAD2397C06654350C4C62
969131FEB6446857D1933191D69B6A72F68743911BD163518B524C58B39C2756
72D80F805BB7D2D3A274567E57421195BFEA147214B266C20BF01490A8B5332E
1C3015597D8EF8DE0864562E5F91592B8AC53C6B73BACF76E1D732F894C4CF42
8F31081A7986C19E06A8F191156B5F7CE746D8A625965D3F3A00A3687591AC13
155CD1F669E20BEC4706DF12190D6D9BCD96C11ADBB4ED28C3CF67D115BB117B
5C95FB544DD0AE2B9AD41A4996F3C82756264C51F76ADFCEFA6CBFC3B37D4FFB
09A43B30B3D895AEE8DEBA8CB89756E1BE0781B578C4B1D3CD2183B84BA7627F
D384B657F21A7E5E789235CA945C545C18322EE3AC351CE50F04E833D5916658
134AAEB467F35E4E28DE6F675B2FBE21F39DD52EE1D559392D1E47695A55D816
FFEF3C8324E8286A3524FCFB9E4119ACA593054A2E804A4997ADFEE6D21F67FB
6D16AD308B44F702F7E514CF31485246E26581A327BC95DC3420F5006366619E
4E9AAD7279E9AD1E62EF7F75313DCF0512BB2C3D31DE216B78B00283F43C5552
B46E53CA6BEDFAADEF42804B0FF9C770450D2B6BDBEAC23E910CD8419D29FAEB
2366B4665916D9CCC67BCD9FCE77CDB4FB7E107CA3E90A32916D241F4BC975E7
96B835B268FE2C25B4CCEC5E3B9730288C198C17D116C6B94653CE8F1F098233
4E7B4A9DE0785C60D1CE4BB10F479490C5DC550941438D3D16E1C38CDB5F1148
7435C2D5DD15CF6443BC005AD3AE3F28DF7B6E008DDCF7A33D4CD50BC5D9CCE9
D183F06C7D5E178FA9250D71A3629D20ECD68546567DD661B7A3D2B1CC6420C9
99DD638680188E87C2012E55CD16160A5C551C1CE061E77FB2471F543B34BB6F
072593C82EE55A9CD41E8BAEF4799FF6BCA97A7F8F81CE8536005268AA5D1F1C
6DDFD32B71818BDF291F761605AF7958D93F860377C792A25B88CA41FE2DB804
C2195C06799A791F3FCAFCE52AFEEDD5F6779BCAFA8A5AF6CB1C443BB0EAAB87
32033E7042953E8A03FE01BC07C04F21A1A0E68DAFF7F663872B230E92264213
C0F02821D44F42E756D99EF4A23318448009BEAA676650FF0BDFC9B2246512DD
01F8D85B834AC4E142A282D4BE4713A92B0CBBA5A322D80EDA1C2799DCF4545E
C3CA2A4799C741EF0E04E917384FD7887925BB86A7CE74E822BB61C6C6288F17
D42BF6A5787FB6549CD528D904EE488385C9549D9872F089F8448DD5506EB3A0
0B5A381AC929AEAC999C45D68794E063780635547C7147F2292BB46CFAF63A6C
181536F007E4B70757873C493386088DAB891D42959C7D0E10F293835B348510
A69DAE8EEE11928BE401F71105A55C8EDBD6C5DB7EFA7C3EE13AA6C93BFD34A4
C309844068AF32DB573F74FBCA54E826555534F7B5A95D033018BA97B6BDB453
AE192D35AE0F5F268E267015A7DDCDC77364B39E455156DEE3D0585B96A53FEF
210C2D7023E726563EF2BF3B84154013BFBCBD6638AF57AEC5CBF44E432D8F21
0EB6DF74F85D59EDCE941473066537A90EDEABD5020E6E7F0EF170AD8EF14059
680E1FBD1CAF8709E10F0936580F13C3A80671512FB13838CA40D55D04AA9BD8
6311A07A51FCA31835C4E409722E008576BAE3B7E74B36BDAE633BAF1EB2CA61
C04A257F57282FD657069EE60A0D49021C7AB31E68FF7CA32EF6CFF2CEA8AAE6
FE53C5402A91CB69B7407EC7C5AEC12325DEEAF5E14CBEB3DB4DCAFEB7173A61
DB240EEF609184D44CD1AA11BA71FA33E5A2BB38AFA4C32011837B3FC6A84174
B18053A5E3DD186FEF71F99C38B7A4A16F0EDA40688BE50030B9B091471D34DF
9D395506DCD5A26FA4889D137451F18D687C78F97439214C65F426455A248554
8A44622EFEC291C094EA252F7EE034B96CDE74F02C7703E7ACCB3DB980055E3A
5193B148B4FA849976F14030C1F81E2A5BFEDD4641D7C6BEE5F620EB923AE30F
9EDC75D8663B3A4D111666649D14C6189EC675184C542FB4BDF0483FAB36C93D
C506F0CD165A66E6FF851C7094FB9B1C42401FDB2645B5842F05A92D6850B74B
B491146D69F71AFCD9DA0904462D619CD13F55B164F4AAC92C2EAD74E26776DF
2366940639F37654AB9A069DEECD5A53103CBEF9F134AFEE283070B9A070E6EE
3C5DED44408CF5EF2BF9E4FF816C15F3B24F812E70B24C8317062E757A8CA24D
85778409CB0E178DCB0BF0A395F8632E9136E6148CFD246B3952F087DA41893F
B0A3D0BDFAE053230DC73C21674B09FB07DA9C32A634BB57FB4E6942F255EFCE
EBF527F77139BE192B15706191A36EF5A5B3B3C21D351A7412A1F9E10B470415
EAF4692817DE20A3DCDB2FD0A447EA11E49A4F7464DFE985F5ED1E7CE04FA4FA
5ED6A796AB2B8B56BD1655135504791762A670CD751449B15C41D0453DD68F03
F31FC7507846506AA0211D519C1F6E73CB6AA064F587E09494251DCD72E4586F
B7CE271A26CFC33BA71A8164C5035AEBCAEA1A57FB2E28C2D8CEF24A6D667AE7
11997E24C83E86F93A51A1C0A33133C88522A0DF82A9748468848493D1EBAE83
AF712CC3DBD6B0FF0C41E97CA07D5236F75FA4CAB700227E8F43F5F65962C09F
95258124474F191F9A71AB58D597A71C8247BB9E6FAA84807A2A10BDD2708847
1372DF7F673A2212BDF7C30AB89E00A31EBEB8C99EEA9D60D6A79A286B1BB4FB
D4B64C5DF7DA3453C80739069C618B4F176CE1FF7AE473B31E4F9AA0371FB494
5AD48AA3C5F9D53455C63CF062D285350464F3F1536D68ED4CA0A5BC88300455
07E82A64D78E01914B1103DE211A2B41CDC2828C0A93E6F97337D2B21348CDC6
A0945919CDB2E48B8FEDA5E7626BC480125B00135DE9CA2952E81F8FF76977F2
ECB7A16B1162EB8C89F4DA3BF0F2B3088B1CAFD416EA6998DAF6A393D533C688
6B303DD27D79BA3F26C5B69EE01F1AB2B6162DB16D5A06E3BB3F69FF9405ECE8
43B5ED1BFC30A26B7C71437F44E824448275D20136AEAE4244091D5798794996
F8292EB4F8CBDC597AE7672B12F84195F5FAFA30AC2081A398F3F8758D0EAFF2
CD82C08662335D724989351811D2182DD881D3CCCD04F379885D9297876DD460
120E025656FED40459C3113F08C2BEAF876088F898AAB020FAE21440229ED752
3202010CC173E6D0C0F84A578B0699E0BE55FF276C4729C19D9A1A1BAB53B8BF
DF9F370C9AE9E193D70D99E30363CCAAEC7EFC0F09AF38D63A78F2EF099FC600
50E1D91C4C913DCC5F8688BA7FF79F38AE6C111554B4DB3EE30990EB99FDFA50
F8AE0A99C616CA5512C15CCE825D93136D79EE66516428CE50696C88658FBC14
85FFF86012EBA75C98BB0973ED6ACD74926F1855DE82EE1839A63F04CEAC9F9E
8D112202E237CD494EF0C34D750A5472F00DF1F7C50A2E48115B1AB993828BE3
7B9FA7E7CAFE729195673A24B0F054E01B98DB516B0A6E19321F61449B4AC67D
C333B0DA1EAA9813C21D490596B46E3E1BD5E2DFCC41C3C36F758F1274FADCB8
A24D144FF1F5D9FF5FA58B3772D7EAE80C0CDA6266583074134A709A6F73F0B6
F2C216EE847B415A0C8003E377D20C7414E02B067292A6B7306C360BD5E81A8F
9E1025F037382E54571D4A6078F11DA6239F7586E1F7080529EDA316E2C0226E
CE3527E48AA1A987199EA0AA17286B64835786AACCC59AF791B0702CDF25F4F4
C4352F6EAB82445E58F486E7980D8A5156B07DD8256AAAC511989644107826D2
88335146E6089192C1EAF9B0715097D7C4B7523940D3261E5735A9691EA3D0F8
8327E38F4C47FDF20752EC11FAB2841497C2EC6E5BF343FE5E327AFF0EBBDFB9
89273A145314A3B3E59A0CC35A2068F36F5055A56C4D43A208D4E5AFEA325864
3C718741B39F7128FA18217DC7D1B98D9F7C6D3971341B22F6B14E14F9CD10CC
3D19436CE45E4CAB587E20929353A3649C8ED1E08523E6A60E1400556DEA895D
AD4000C6149FEBC0210AFBB4B64B6CF9E768C5F9217D84EBCCED560CBE1A5732
9E74D7D5E8DB734129E6EFB693E898B4E58F6816A63D08F4E26D56D80A55B21A
D9DBF541DB356EB4B21A502C895BFAC464768E62A0BB564318DCAF242C41B00F
4B2A7637C40F7BCE7311EDA1D11B8FADA8607AB97EF1CAF2B7BAEBA7831FCC4E
9BE034A9732BB1B436D12625772A3E65F8DCDE6315DA72598C49639F8C3168B5
9286768E74239DB9A54E5082E7BF26DA44B9B1B64F24E06EB067AB030BDFA4FF
5C0C66A3219D3A10FC3FA21F8DC80DD33DD6FF2CD64672742B67B9097B6A5FD0
34500D0BC06C4701E48CCE7E8A42F696FFB479612DDCB3A961FCB63414892A50
2785C28C045439EDD8098167FFE68A77C30DAF86355562021C4824BA18726BF8
6FAB69D6868BD39C6432A5CD965E294F06FC9EC4A1C9A84B5553620895D71F76
474C7546219F9F33CC10F9AE1E25F07B94BEF01CF10ADC184BDE1001D338DCA3
AE4889A8717D0F7147426F8DC4A1EA2AFAD82602EFAE7BE17AA71D5A80468E39
BF27B3B57AB679F5EF0FAE989CEE4D91EAC9C157188A7A4F3BAEB1E8AFA2073B
4C85F932FF22C0F94AC4A5A3D4082D6C14C7DE323776CDE7D2CBCFBC86E3E713
EF302E35BD68AE6A3DD2AC97B7BD96E153653E0B24012396FB126A0C86DCB6F9
4F0570F77243BF959E0A32BB58867D3E653362DDFD389D72CED78E3893628C11
8E5F41FEE66A417438DCA18A7E1643DFE3E83D6E301F49461E0287981CBC353F
9F8D272E92294C6E10DC7C89ACE04F571CB205AC454E76A88730F1230C0DFA31
2657E2AD9681C11015B9B45CBCD55A1E1837C6DF9B1F1D8E1AD279BDBA6A69A6
40B56F91779893A2A16AF300CDC64013285EAB731C5164954DB44A04CC5E079F
B494FC877631992511A1AD10C7CE19DC17657D2888FE452D2C20B92BCD0B860C
43C2013264761068E318CCE5A573222B1612C2423516DCCCDEED1FD046E9F0D6
3377BE355555E2015543B75712E29F6D9525AF917F3F1BAC31C10A12F7BE75E7
7213D146C861D49BA2903A4CD362CBA265ECB643164A0680CC1882A3569A5C14
493CDD4C024DDD870F1B0F38FB66B08EA3EB88CB55BD9FA6BD61E07FEE8B9559
83BF5F4BDDCD0C845865172FE9BC99EE93482A591B2AB66A2E25876E8AF78E72
E2739848B5E82B2A96A9B47C0FBDC458DFE5608FBBC14BB757426C35FB499CA6
1F55F0C5C44CA0ADA09D2B3CC146394E05E78D13BCE4F27B2AA69949C475E87E
59042457683193134124DE43080208B387FD568FE73F8B60202B4133A4989FBF
2E1279A4C5BAA59CDE1367D23C674ACC02EC8FFEE2A1E30E98E8E61562DAA7DE
D245ED06763E027AB627EB7236619918F79FE5CC21FB1091583DD8E4962230B6
433DF7509AF42369A43D06FF6C843934AF7E20630A42589770A4FC754B09283A
E687D23E92FCF39195EB2CF309869E95E19232A0C2080C98719405809F7F36CE
DF5D51EC302097D4028E6CA2446BE848E5CDEF50E5A201E648602407B43B09C3
894BB87540BE7A4FC97AC9613299048EA405E0EE6CC54E54D3E4081CA5D6DB0D
49D379B2C509AB7543A1C784211B57BB5403C49334A15285A2722CCAEB164C71
ADEAB65C0ED2A2AF8A51F66E2712E658C03E6DD9D0E2B439B2A7A0960D884E07
60403EF19B74A5885895B3503F40F001166879F30CA74CF5ACCCE91BC559F619
32E38932DE8FD98F0E77661E3287262B195AE3685A52FD3ECA3E4C518AA4D56F
33E0505C9A2304C2ECC322E1D6CD2630D0FF0C5DD2BF35833BFA67CDCF897A2C
B93FAB696C8A70C6D82661990E69597B4E1B62618EEA21383D082E1DC7A16B23
AF52864908DCB5C6118CB89821B802A8A7526BB5B5364A41CAD3CBE45497583D
0346AFDF543CF02E4879B2F887E9EBF098BBDC29735CFC10B29DC67B82B68185
752525A204309C58381786A90B56283A50F5EBC0C23C11CEECF45F5713998AC0
F88B86897348E1E1D2A2EBCF364ED0EC69CD4A10F75C09CA5463984226407C36
9E805C98678CA2827C5461B3429AED698B5ACCA0B4101F526AB9DBB3F664E31F
98ED1E508732793D56FDE3B518894D2C2B5AA528C22E00959C6D6310720A4785
DDD124E57B7EB87E2B6F3D8F3C0FDFA72BF6732CB2357C4C15FD663F34B7251A
3C44ABEE40EB1039C1BB6B1F1651584E1BABE5787E2A2D958C18EA36B31ED7D9
901458041489098C8E17537D80A4593D7C15C786D503F70B4783B93F4884570A
F25C7E9D16A405A4AB14FA152030520D350B42F33252660FEBA408609CAFA6D5
0CC5271C517D4633C2308E27E571D13E0FB0953B1BAF4A404C7C8AE59E0B2418
5FEA54E2AC0A251AC4984404D3BF624143E102058F18451B5AE471600E8D3549
D49BA0FFF917FDA62B03C7B88335EF3FD430131DF141961DBFE2EC308DB88409
1CF7C66458566BBB67EB848927F2AA2A972274F3E180A16D7131BB65157D8651
42F43786FC94BBF285CBABAC82BF0EB167B5BF12B5F9A955C2E38325591EDC34
FFAC759ECA2D0AD37162CFA5D18D27040004CDA6E9BC3EFB2E9C01EBBA729355
B6AB9E4CF0EB40DB7D1F66D028D4272B3B778F6117DD0D185207D44CBC57BB84
42E78A76755528738497513F8D9023B52493DBC1B7EC09247921F6612ADB0072
35742183D589ADE094D057011CE729C4712DA921F57D974C323B5DD4EAE63BF2
361F7DF6FA0C495AB8B681ADFF45EADF68B6DD3CF0F489007A2EA71E10D1FA60
A97DC60F5FF536A1A32D9F62960E233C5772F12A703A11BE5832E656E84061AF
51C4A1EDEE69A486D0B8DB50C04BF95A63D0D92FFD1E9263265CD5AD5F7CD57B
B8E9280CE3C8C65BBCED0FB3CFBA133BA6DDC0A093ED3C65C45319B7859B5998
0B40EF026255F0F24DC9AC4F5F99CDA202080F2FE37F8BEC5E64807AF8220CFF
A44EC62D426C50FD24E2E89F58A11822BC91DCB7A189F24C86F354F494A7D8AC
6CAF57FC08759EE7BEA16528A950855D1981FE5D67AA483B876D1BB1186A983C
F7B6D2EEF9D3534B07495D1A541951182114CF54C5A2AB68FEF61C89245F455A
DE957E2E6C4353F57B0E4B17D08B4F13AFD1F1B3FE62BDC9E5731809FB6B6F52
5CEC108274241F45BD6840B9B4D019CF0899ADD3ED79C49CD8F1F5CDEB04FC11
1D40E811037F1F901C40144B2B9C8CBBD39595AB876A947BC52A22005920D97C
FDDB96555C10C39F7A01F4BD88BB44EB76C8AC4E8AC8B94194FA55F9DDDB38E2
F757D8DA776FE1BB2D11A03A40D96FCA94638F6706EDE418EB3FBC6595A96378
EA83FA240C02E612EA5C1ED865A5838948E31FED0EAF922A284C560EEF422B72
1D5BDFB772D2BCA16FB43A8A469682D8A40446B8BF3A1F4BAEB4E15F069FF2BB
DA1906F8589835A537B707A239EB70AEA436C65A76E7BB62EB4E755C33144C00
1A31819E740FB750BEF86B464FEB95CD7A3276820CE05014B0C0F4695893C8B6
9938947FFD803A23EB2C0FF113C25B17C13F40EA07F4BA8FCBE012085B6EE371
15D7B712CDE1A2C2FC64D84E80D98C13CCD6349DA35B8882D116DFA75CDCA78D
98F3B3164DA2F0E6B05DDF9DD6222661D2CC43CC5C91F47ACE240264A1C54546
4135744707D2D0139EDCE425E6C42607382F4C9E6638603914E207814271D14B
BA5030926CD3467E30EF22C5C44955BD4EE83DDAD791C8819BF017968C5FDADC
4CA56B2844A6F65BC3C3B208A67F38111589ADA1EA9EC4D2583CCB744395797D
F9F845598911D014F5123AC7E152B0C216644EA7D423786740A70418E93B5B1C
2E6D31D18EAF73528FF2FD8B4EC9CE26193231B5536602D82AE4B4F7A46BA4DD
297D02F5E9C846AF9F72E561F590C444EED0B5359B92876EE69A6D6C3DEA3884
FC463F1476A11DF910A210DAFCD71DE35BF4BB91D0B3588EAC7A2F155E69C9F1
A29E8C768AAEBC9AFFD21CAA9130C7DE04684B33F60E00B81E14CCD38CBA5700
5E5D450228A09980A07E1E711F1F4DFC7042A9170EAFC678B7FC6CA48D627D29
C0AC1A0DAE705D52A66B73195B5D58FCB823B9A7F1A386DFC4C7956E68171DD3
5C43C00DAC64BCED46B17F0A32D5D801D92BC1CAB244F37B6947553003DB4B27
CC9CC38B29A8451722623AFFCA70FF6D29EE20C8F451DA7A5B8D7D927C79E8A0
388728FDFA5FA7CAAE35C558F3CFEF81A49C767AC4911FD89CFE786ABBD09711
DD641F76911E0B9F7323715CEA2BD4E5E885474524FDF31D2F70064A1BCB49E2
C1484ABF6389C9AB3C6588EC3A9F666ABA4F63BE7FDEACDCD3096E3AB876D7BA
ABEBBAA76AB485012D6B7FEA73B7DAE169D46EFB77E93D1F0B6CEB9D72A51C37
17E41F985C1D64983C5A85BA2816F19989810034AE475CC51562040BD13498AD
FD11719A3D1C3661B7DA9B1DBB50B0976EC1B71DD8C066F7BAFB8F617813C1D1
A6D00FFC58BD7866841EACF16037E3803352E221CF72B34BE25CA7C1AE2DACB5
C50EC60E2D56784D41642B4EF58F6D3BEA89907B44FCB97B5961718BA5E08DA0
DCA6F9888BE9E184CF9EC9CAAF62868F719E19FA46B9E7A7B3667487E775A0C7
C6FD239619975AA469C0A3C73CCE531E67F30E167F99A9F2144A556B279FDB00
F769A526C3D1B871BE200B1EC0C25C1335DE12C8E6CC44A1B8CD29E5B020ABA4
0C372995E5E358DF0BD4198FA6E6EDF87E96DA779927AE69D13E24544B434B09
795EA385D6EA54C21085DA8296DE9EE189C6B0E2F2DFC461AAE963BE81278177
01AE96D176A232082CF55ADDF890BDFFEF363FE9F91946455CE94B35271D0A5A
25105F8E18A95054BD790018792A76BACA59C0D7993157A80493B2B8A1BF9B85
2ECA722FE9FB3768AA432B7DEC7E733B0667DE8D4BA5B1A69E97206024199774
C938A52C85E03DD42271A7BC09C5A900CFDDA9FBEE21CF810681395354BCB4F1
C192D5464DBC0927C9C93A704D94FA342E3D0AD35BC1B3A0189FF30D86210D55
95893E74426A7CD2CC96610C4B0C7C372D8BAA89CDBFB152A9FD48D00376A91D
469155B82F94B202523AD382AF58ABA4369846A37CC75496FAC4A79471C21C4C
B1CEEE78205371EA7F1AAFAFC79E47032B30343807EBAE8DB2FFD11C2243D51E
7BA92160B038D34C5D7E2CBC06DC191C3DCB2068BA41ED234D0C0543EEB9F046
9161676C5BCAFEAA66685BEE60AD812D3F23C394AB9B119375A8724383979071
85982662F599510985D6734282591906C2D0FBB15FF80DE832F016A8DC14A205
681BC48161F552B31A869B3F745EE0862F912C1E0156E9856B9C235DE73658B4
0656B6413AED202F10393DC96025F61208AF8F0CA5EE3929
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1347
5033F281A7982AFF6446A85869173384CBD1238DB5A921B794AA7565EC350324
76E1FE76CC0825A72B9052D39929D061558AB36D6D22B5F84B279CC8C1DAE294
DA2DAB134D1A303D6A5F52D647B2DF907A4788A8A71C114A56218C148C505EB3
80EED33B983200780278D973CFF48B36C5A7A7B0CF06EAABC7F429686BFB49C7
0FE5A76C320DDC3520F45B5C4443942B964A6D5A89A1D91B228140064447D3E0
5B1BA361CF2B70C2004270B5FFF27CA0BBA47550D17F2A2913B60B014CDA35AB
EA64ED91175CD1D3A285AE340C54D282C98740FCB316FB560C4994FC37A46E8B
F213466DE9FD1DDADA7DC75564EE9018765F8DF8DE9C73EB3A2863DAD91997DE
751F36A6BC7EC8DBB0EB5E07FF518086FE7AFF6640D9E4275F04E2BF66BD5949
AE733BD8D545F7A53BB71479FD9AC22E4A3AF5FA6F4C6D331D96D57BC7AB5CBE
BC7567A00107F151CABAE24FF01340F5A2A6CCBC3DD8120AD4BCC0ED71AE3947
EDEC23D18ACB7DA20C340ABAA33950A7B84F08782342127AD51392402B372682
1F4684CD70084AE25A6889B429AFF97366C6142BFC266395746894A4603B41C7
C91EE71DCB66501B86A8A44FD4B0FF245571C28E279BD167FCB36205C7711B49
39EBC385EA919D72C245CE3BCB2EA1EA4D683B8417500172E32FE4AE1C62C77E
C0ED1ED784B9A821AE7CAF844B1657080F668F77C77D1C1E2A8F4BB7DA76A97E
0C65748F25A4DF3CE3826A867A43A9D4FDDEEDCAF206978C08444C01F6B9196C
D1C58BD738A1E6703EB668537B20AC23C65A71F2C69377730189C0D690FE4152
F2250B7C6831F554079420802B29FA50713ED2F96A0FF18D626A206F2D71D4F4
AFF8425F2C2157E4B8619F155C66DC6349296DABA92B140A3F7481457123AE6D
B8994DD4E9ADA1387512E9888ED60E45EED723C01F3A732DEAC61B7606A35FB0
CE70ACC36E1C22720C0C78F43F6DF446974C63420C816EAF14A6A04E928004BD
A21C9212688E34E6147B0589778EBA8FA68830E68FBB7BBAFD7E3F8D59B8D7AE
0C367F083F6561C90B14D2A9ABB0E91CA39406A8E8E0E138FEF0F6C4650F8784
8033C68B75B9E4603A9F6279A8105964B5C4BE9E6EE4B30BD9724F398FE8CA56
445DFAF3833F3FE34DF9CDCD29C31FE1B3023AA3650BDB40A618EFED89C424CC
B9177866C865FF19A49E13E76E80ADB1EC4B28A34548B409866B5BC695401E0A
D631D2E0DA633F5630E48A1DD6CAFD111614267B48C91C1B998EC0F54D83D1D9
703ED66E5BB41ABF270037C9B5E51336EBE3AE8B6EF5F0EB29A408B8200F2AB7
DE32144B10F86C7E1454FE2208132979DD59336B57B9B132BDB90C436F122662
3E88BBEA5AF856200CAA428E91B65ACA882FFA7E7B566BCA9833124BA3A881F8
6F7CFD49FD296AE847C2107231EE02FF872380251F4A4612615498140CB8C635
3EBD8A0B47FE138D7081940A1A70E1039CAEE78B1FF3F937E9606B929E4FE607
F5FD931CCC6900B26A1B01BA8671BB7E3CCE665ED2BDD890E1D885B459C3064E
8F923D2241DC2A4B66D92E290D81BE7605A534DDDB4A69FB93F10DBBE08B9B02
6AB9A677E27FC3B92ED8B82B6C2E37EB6EABD34136479D92A6D278952CEC53E4
9B0F795D78246A18A8D921254962C6CBB4895F7AEAB0B4FC544455FE7FCBE124
F9257906262C8CC08613DEEC7433EEF1BB68989E73F41162443F70D37CCF149F
388749375D92AA336AE0A2A60A0D4B701FD053809FF5DDAD6266E74B8839E880
B3DF3F235C97C31C9BD4B4191E5FE7E0B8991EE6081B00D74B008A7C2955A05B
7A29B1D9E25A5BD760D3A9CADC18871F4E6E4A6E79A8F4D727C550460906AD23
EABF8EE58D80CB40CEFAD6B8CEC4B1604ACBCF9233E03ADCC793ECB4558FA752
E855CBF0206FF63B66FD1BC82E577DA41C5B8F6BE9C3810199BF61E02C9EF00C
8B478D27D14F008E134F92DDDDF27B0F036EB48BED8E7F3E09F9302D1232A122
DAC6FA98B6CC339083ED6A04DA8496B59464C4D558F15D8B8881221E3FB52D67
439AF718D3B78256CB9BF699DC5730B700F1C6D8109322DF0CCEBDCDD341E13F
803B2BB020BA7B2912B3FE793C6BF6A7C81748D366833CFB8C9B7A761EB70076
6D976CF20A782776BF2A92F74A48F815B0E99873D98F61358A267105EC20B825
2115CEFBA009CDD6A111FF754A82A584DA6FB5ECD7B6DE07FE3962E2C6751F89
7F01997D20932CB44AD778AAED1287E8AADA1AE42E562D803147A1B3C582985C
51319B0B1F56319DD88FCC4E4423CA8DE44CCC2718BFC37F434681E92D2E498E
8B038B5CB39D4D7BEA45FA317109628C36BFA67F7A028F1FFA20539CD88C2616
430A365985F7D9A1CEA61AB1B4FF9CC8665A3C51B5D59C45457F8D3D390F8ACA
E4E4A7DD9DB73AEEA11627318A206241A31316A90F446CC28514D91A9D548C92
DCC4D49B1F64F6821F7298476B5B0CF6361BD0532CCF260683900DEA8633BB86
D863F261E896ACCB689CDA9BEE241AC963FF658A87CF9D8AA0088C8AE188FB19
32D856CFCE93C8E10031A8D199E57B11FCE65F1E571F18FA119D738148CF0E31
AB98BDB3FB2C085EC0D0ADA392C7002E45211576133D8932D2E3C047808ECB9B
4E3B04FAC71CF2763EF25BB1D8DBDA6BBAA4A7EBBC9392802AA756D295E4363E
3D67162B929DCC5BDF6988A14CC90432386E51FB9A5ECCECECB1ABBB29FA5F02
E0FF3BAFA642B1164B87B1EA772FC44D87313FA25182E3F959D44088FF71B104
3CED64B2D5B0C82BD11FDE0E5BA135A725568E6174A667F1EB2D76F0ED86B327
D7A828EE3527EAFEBEA3A7F3EED9E595009C1D967A7482B2D3DB98B45EAA3B28
3B59CD920277F1CF131075E13A152BF9C80BBC474BFD9BECE8D4DA7117B9E4C1
0A8F23FCF526F55F3D193C751ED4E13297D7885507C62A8CFEF7D01DA82DD41F
CD630489736CFB740087C30CCCD0B8F94F3315918F3C5FAA2C6DAA5314631585
12245298CA2D81A942C68AAC9EF9237FAC80927308B2B72916EACB67AC9A4CA2
345E4EABBE38838E6E37D565F95DE040BF06E5232268D1B511CAA6C6803BD53A
8882EAF77EF6963811F2D5F0C2DFE72D7752FCABFE9220ECA8954FC5EDC78C16
1E27E4F8FE82E0D9A3BBAFDA6BF447584457030EB15855AD3DD3B7C4599E08BB
84C75FABF6BD5E8D480CF1BD8512F623F77BF90DD8864066685144EA4CDD5853
E2B879B9C26CC9090EF0D38D878975828777532C47B93F97B7A0800DCC0592D8
4B4BFFEDD140305451B45EE0F62D9291B59A52BFBBBCEF2EB65FBDDF31583EDF
854D06578ABE923BD936DA936C9A0AC65CE3A9548500C2B886075CAFAA40CD95
44D7B4B835F975D21D08E1C8F6AFBAC6248D3055503017641863900214C720B0
B5B2D81BFB6816DC7887C8F9F74EC961CDE13A7E748B283EF0D1F9C816618DAE
B5365720179D19F4FF6998A31AFB33D68BC88171CBAC1D41B43C6B5705CB9DFF
38300B9EF15A312ACDA6915BA90063C56311014EB39A789F0C4CE78069475B5E
4B670FA2BA8A467B15BEB10C37971E766FCFC53C4577F5D68B5EF0E18E43843C
45A72783A186DABBFB489A5D5A12D53E85F2A7C31F44123F29465AC514A2B70D
C0908B63B52B984D8391092D339FF5C8075F32AC97BE9EECEFCC5105B2FB56B8
0A650E2F6951CDC1874610A1EC5C464B8F012947C827603D8470B06884E084BD
DE7D2B2478C42688AECA8E5304CDBE68BE5DACEC430968525DC344DBAB955C2E
9F9907D29F16CD90B905875B53D60FE6C5EB7D6E8AEED7CF4C31CFD5E8082CD9
9B7BE874FC4A39385CA2757CA7ABC920C6A6A6BA86F77328D60AFD95A6A758F7
2040FB714570E828171F7B7C7AFBEAFFE1226B7C9AFE6196B3D0C4B0F0FE41F2
DB3E849EAB89A17B92DD4FF88AB4B991D8822847C7D8A9E9B5A055863011216F
3F8AF617E1C2A88F617DB7F784A6D276F8A91867D9BBE00BAAB191FF5B0389A5
8426D94034D7DC023C0C14112AC8D3E10656D67BD4C6E0570C264E17019BED0D
D5549F1D6B75D752E7603C99F73841FFCF70C073337E2872A401DB454BCF21B7
A40681921659D4B2A379AE1375A60F63CB7979E221F6C28E7C2F44B77AEBA567
4EC79E463700DEEBA011CF0C8F08033E523AA8313C2A7C978F3F58E93546AC29
B499C30FA5E25A047E45CBCC867CF4C02FFD654F0D4EE4881BB2F335DE040A8C
1667EC1E0A7DA9257C1F77311ABB8E2F26349004AF0F6B8C4F251290120079F7
887DA412D696BA9477D61B5348789BE20821128FF806CA5376616532B79C92A5
B77292DB05270A72F8BB0014487BE8C925BE37F7868A56ADCC26A6A2751759C1
C12E56DE0175464EE25686F4EC045CF295562C225B1823A46E833E6C0DCF57B6
A60DD4DDFC42EED6B47FE68EB2783BB15AA29E1CF5C1B8AEF5E1B5F1BE0D3C8E
B03F6536C3E621D9AFC181360FF0E7422E8DD25661CD38028370500B483C4C81
188DAB869B5134BA7CAAF7A6067B19044BD6B2638845279D79C756286CC41E62
12F2413A82ABCFE015E1FB85E9C5B21D2EB98AEABFBA9027C34F29D26B5A0FD6
80DDA60342D5C3C6BBFCDE2429EC0989A3C09E4553B37EFCAD23A09D01715572
A97C06E0FB54B29BBFED7EFD6B35442192EE98C9109DA71D85A35F7222AB57C4
88C22C5D5BCE4A09EB1E5008CC54BA8BB4D84BAC4D649647CF77B523A527218E
4AA3703DF20BCDFAEFA66D2DA01640B0576BD8544CA6AB5B87D0B03C1FFEF085
A0B6BF126AE65C2CE72156DDE45CAD0680837BF7F8CB151ABB8F13F0EE51A058
F994B32222535601831E82EA75026355821A03661C62E8CB193599349A912FA1
E708786698ED5CE6A62177C66ACA98E64238578C1A587B0F95B5D99A3CCBA7C4
6C157E02CB2295CF26A468C8550F1EE37BE822EE2721E984D66F07F63D81F7A7
ECB4A3407B41E06CCBDFEDCFD1B15B09C17883D02733D0977F1EE942CAA7C7A5
AE5272C1325B394EC7AE70DC0AAC12FD84371EBCE5B655CF0A88149C84C6EE50
D961FA0F2D3A631D123B037B469A242561B58EB3369F8D42BDA1707A229E2EC6
B3E6E309E0AFC3DC545F9397D0526C1984B98D3CBDE7F979854CD11DE165FAEE
82FF36C0E44EA7FC0D28FF0C8368A9D04208C4D94C7BC4AA236A5F8ADB04BA52
7F070E680B42E5438DC4965F5802EAF4DBDBF6F0803C0FF1033BE014B1165E06
D215294D2952D05A84183993FCCEEC9EFC8C44C56217E8738C33F95133C72E9A
2EF23D5B983E721B4BAB5483E72CC4DEF46FD4A1B1D92C9048EBA6EF2CB4619A
DBAD688575A4D2874A8072E1250A760DB31625CD1A8BE66284BF1940F24190FC
19948EF5E456DE009C5DB2BD9121606C72C3B9EDE604CDAAE147B9BE353F9713
6431C59381BBA33B4734BC47F3A3275A3CC503AD83DFBC5E2DADABDA6E32458A
DBCB1B650A4FFC3E57E36EA5DF3D6292B2A375CB7C3428A02515E6BAE950804E
E5E469A0E168DF84A748F021AEE121E2043AFA2AA91933A8A08D0B94E931CF48
59A76FC0056E9F68CEE73A2EF39DE412F2A0589CB8815BB33A40C3FA4C6AB9A4
8D0EEA39A25607970652DE1252D6390A871E6A19CAC1B40E52D2DA7E72E57DEB
9A20C3850DDCDB9FFA16ABFEF928F1E28E92D357DBC2F3CD7D9A7C8CCC4B183A
99D3D180D673B740C302DD8C27150D8CDB8D2372D7440A7BE139376BE0AB7233
333E9A1D4A4785C25F3EF565FDCCB032B061AB58683A321AD84ADE1B93153241
49043E7100D5A9A4D384ECECE95A6EC560809F48CA3794406C8712E36D1C8D80
1A2F15B1C4B9371E39055E86180C4F03A47E29FB0A6DC59F9EB1C986FE7A9F38
537FF35810519394220EFB10C66FC7FFDA0F058CD38EDB16E799AD04298D9484
0DCCC3A72D6E690DDB982F55FEDD2379B1113D100703A42D3FA1D62FC01C2591
3BC47F800907EF65D69BBBF89E6CB34D200F70D3AE26F2012A6E3DD7AC3D5339
2F77DFCF7FAB77051B3CE85372C05E1C5D85FE330BCD2558CA8958F05CA09EC0
F53805B0873D4E9589894110FCB86753AB0F25FCA6BBB47C88FBB7CAC0AACCBC
F08277419D50610BA45F203117169AE6FABC90CBB9172BA3AAFC6FA5FF97B518
48560BE3E6370F84F134983AB4AF7BC6DF74FFE9323E0DF559F1BD86E3675C3A
BC3198DC0E0A7B0B3A644C7B083B38298EFC48B276754C98464FAF0D6CFEA11B
269B71E48E02A5A9EC40CDE174513BBF688CEEBE7DE00AC57C8E9BD580B65EE0
A3C17C89601CC59600FE03E37C6624E62F916E426A7538C6706D29DF0BCA295C
846272F1FBF5430920DC02224CDA1C29ED601BE2B6EFA6CD05424C4A973F6599
1F86E5848D7D8CCF7F3C5F26688213003B72CA6F9BE8F1EC130930C2F370625B
DE769F8AC60547A724D00985F7ED4D85897E29D8D0351C31A8224AF0ED16190B
173E5C99CB752E8167DEA1649F5394C49865F8162C27F5826F5D00BD52289609
8DC7529181B8A970D339AD47430A287D7D38E907DECA0185F52E2D529D8ED4C1
B8B7230CE676B407C8A60296C19AD40FE50F554FF34F301F29BA4CBF2C488BF2
8699B348EB368544F645DF7361876A76383FA1A5B5F00DA458BC77A371375FA3
5BCD767FEE7CEA849F3EFC997364B48A6BF6AAD3F1CABDC48E91648652BEEC39
119B6B2EA9EB9BC084F5A45A2CA82798F8A2BBE9E49B094353D7859EF2E693F3
27D25D98FB44F53273DE6878DC6D41B5BE8C6F4A9032FCFC5AC382DC237A9610
5EA6B80D4DAD9B9CBEF701D77D05CEC5FA3DA9FACBBAA604AB2CFEF7BD716B24
01FF59DF84DC27B11B307F385FD2379BA9044DD214031FE8017EB2E0DE91E58D
E438F3A4B1170E2D84159447E0282F1A28CE3432AEF52FED83FDC43699EAE566
BA213B1B4DB2B2F16E9BE2CF4387478FAC37F415FD2F8E95EAB216693979AA13
178DFB8148F709947E40893C1E511F85D2D28582581DF7CF37E576E350F26EEA
B86C4B8DD564DD79A093A254983196E958BF6F00FAAA36C9E55516479205F6AB
C92AED94F11FF1A9C5C71DCC59D705A0D8383FC4F75591EFD63D2BE32CCCDA6A
EF51596257BE6F870D1F0F109CF2351A5EC76576A66F8D6B0B9DE5B9C60CFCC5
7E03C860085FE5EC3F16548E65FDD0BC6280D6E4F49D4902502C34012F783BDC
C009AA08743425FCEFB6122C659DC9D0A91B93ED570C080A5B57E0E8537E9947
91D525325368D4BFE138BCE0D709937C2EFBB1A982DA3A68D32CA7EAD87D5FF2
A3EC4464C8B2BB8711E69E3F91191AE0D2C2D54433588CADED951D772659F051
2B2EFF5804B0E3185831850FE284B0CEFCB04A0D009760C860AA9D845C0C623B
98752E1A6FDA60E3291357F258DFF2EBA9D5EC4969A9EF331CF0B1C83587DDD6
5D8ED323ED64D7A280DEF90FC98F04E28F81F822142BBA1C539D46CBD2C2A82A
7BECAC50896FAE8566B0897585385A1BD3F11DFC964B4C24DBC2151594D8601F
22C0D366590BD75C319091904C06C094D730D5240CBC620D7CCAA0D1D41114B0
5B4368CFEE4FF4B8128C843DA6CF1498DDCEFE21BD4D56075836442C5F0E61D8
B5F4D9120A279A203E6BB52CFD1E419689987E7D0F4BDD30DBD024757E2EAA6F
638C54E5339F28EBA7CCBDBC747B40366A0DB25F6E9E542D734CD279455976FA
7D44D4F8FAE2223145BB54BA1A37F4A4B21307CF8D93ADAEF2D5568EB7FEEF24
3BC68B995E944A4B5B5DD00F98AFE866E528CCAF35DF319A040AE99A2BC17E73
DEC03B45B1ADA04C0BB923B875499A773A49311B6AB1110FFD439330EEE90381
00ACD78C222F66F9D9A6769FF83922EB9FF70550911240EE4E042019BC851595
20ADF4EBAB73776E7A7744F3F8F952C598816588DE9C8A1ED4CEDA6CF086D4C7
B22F21C9BA5FCCEAABEB14240D52145DF460348EAF880F2052103EF9BDDA9448
280CE7A398A633DF18124AB288CDC731BFC9CB7232891A2DB20B0C808F523584
986FDD497D3E2A53E09A4ECCBBD0FFCFB0E17B5E04A4B45065C70938056E27E0
242A3329AABBC0B326B3DF0081E375C3E04AEAE3F246B171B95B619C83F24083
B4CF48B7BBFDDD78563E2FA851CF8C19BA6FE9987223511B0FB9529CD140C094
8278B9A9DE9BCED18349A337648A5B229AD308A72D304263EFF2F1A060BD6147
6B351D4B4F510F7035278F48541EFED4BDAD7E8C9EFF3F48189C553B9F62FAB2
A265DE09B0E7A7A627FE5EA246A036505D0E6DAE22761BB9993A96AEF0E8DC5D
EE84C0382B6B7D81FA2307B2F042B0B80618ECA53CFC0844358B9CE135ECF0F5
BA7AC1F8798117D2DDC7E9DBFDB74A53A95C73992110DAC527BC8FD9FE5B30D1
9D1B38E65A28394D72F75BC7865FBC04BE337BB5BCC8D06F0C5EA658D362A849
63541BAE42DB0FE6932CFE3ED2226B71E348999C4F13EF86DBD6A91E861B05D9
BFD2DAC29A030BD6D3F9F1E0D7C84387293D953BD70AF44BB32F9C2F750FC0A5
19E412F635FEA2EA239712FA1A2048F7880BA5B30278217A2DBC4F31DB3B4459
43EEBFD15E9E505C13751A6396B189C92FBA1FCE9E77ADECFE7A07EEA25168B0
7A9548FB71216AD5F87245ADDCD1E97FDA8BD4FFA265F7458A8CF6AAC93DF610
C6F3EA9796A3707F23BC0B226DAD6A1987EA8B9FC63F2975CDA93BEE469B0811
6B54095C9B4730F1F2634C3706C5A6E2DA33E799775635C691E31706E51F4F79
713F76280312AA0240DD7BB179BF9109CEEFD917EE28E98092E27362B2B95796
EB6DFC9C84C9A54D301FD690A456DBD9A6BD665228CF3CD2D6F12A427D282B07
510C08E36C7131B4877B413EA18E505C7CAB18344C739074B3DE9E17E227F6A7
CDB394EA13F8E2143D43A14823993EEBC5CC2F654793C81A8EAC943C6CE54E49
90C7F57C89305D2FE4E34A5B08D66485D171C0378299436FF1EC540339BAD04E
131FF389EB3B7E8780F050BD95ACC646A3CCCC0F67CFFC1E0C6F9156826750A7
4B7DB07ADDE0747DB2196A546CD9C09ED409A37537ECF2F0DA63D0CEFC1B9E64
73AB236B7BB613ED01CA7F8CFC17AF02B6D08B1197389BFB70B6EF2393B15E9A
A8D13F6A0D3E16BD4A9DEAD412EDCBBDBFCD424C93FF2897D515655BACE13C19
CBC0961B6654C0AE9ECC72DE0A8425082B6643B94E4C90D6C95F5714B2885F1A
C3D9191E1DC5CD89FD905B3BABC125351097FDB613F5F3598120BD145B0A9481
AC425AD8B4DCE63A6A93E254921B8B0D960A0B4E66C309CE77805AE66217B0DA
931A452A7A2AFE151DD5106981B17F8932DC6AEB622ABA0B3D97D4EBFED9988E
D7A2D5BED7E82D21C2B514237BF862FF11561F48BAE3AC34BD3EA885677C29B2
93905951356EAB836DAC48053037A18DD46868E3A89AA8A18E4A3202CF5BB04B
E333A900D68B8823227A3879412434C48AA355F27B3D86B0A8AF54AD21E5D9A1
9692981A48EB9B5D7F61B2DEDC1B8FB3F8FA0272CE3034F727DDAB551ABCE205
DADF6DD7BC4F4D1D65EDF8F1B30EC9DC1CB0740B3FA180C4F8B1F8FB7EB1529B
2908196724949CEB89A93924E8C4C56CA2EF0C166CFC9DE91A0E50161799BE7C
118FE2BCAFD3BDF6B3EE7AF1CD624C00758EE3D1E1F0E13F09BDF18958307F91
CF3B2D50CC13B3B6DD8FB20B3809BDA31CEFF54416E978282A25E12F04FC9F79
E244A59B27F67A59A8D65B0B55657A804EEF1619A2FCB73500DFC5029A78B4EF
465F826FE289240960A8D6B82C973F1D0CDB297D63C7CCFA854244F58AB681FE
E9D6D55AAF5D16FA558E434B9C650A8EF8D238F588D612DEBF7FA0604F5BF7FA
6EC524FEC5C3D513DA95A52246308DA1C8DDD11B9AC6B2B9B16652CAAB045F01
9946616A36205936FF1E12AB2589536FA3B40C7BBDDE96E9AB4F9FFD027E6450
052CCC845170D1EFECA8635B7A03AD664E97A640B2B6609423412969CE3FF62E
75FCA2EFD405E619087928F86348FB9A512DE96AA15713998B8E4A8DCB9F5611
6198F86D5F3A97ECEB0B630D6D06E37E13C40E00ED284BC5997AF881A7BFEA7C
740B548A2426A5E291FE1DCB131CA0D3C5EC1A9A84A3A7646D35CEB82ACB5BD4
B32289F7FEBE8D2CB8CAF6B574B72076028B38DD4D04CC5246DA48AAE4250DD6
3E2AB140CC0C166B4A3BEDD69FE0B1CD394571392C3DDBEF604CC57FB6B42B69
9CE80A7F34D71033BC87D3EB9AE07D099C9C12631402BCB7950C2C03647ABAA8
D2E27D3AB84C328831E122CFEEC2ECE36AF6F84F4C20404D0BAB09309561F40C
279E4B27F62620A76D280B6B1FA9FCEC2F0F40C2ADF359D884F5E37AE6B1BF6C
154895805D10E2027A98BF9148C6C0104FAAB95DE35F7FF7768EAA14EEEDB424
D767E2103BADA0E97275EF708F4748FA4D5916E2A6F5856A14231A275831BE54
BEF4E2B2722067752F1A7B4A78CF4AC14E4DAF3BD64B6C4F4890B244D048FA90
9AA9257FD08C1890BEEF6A5F835F0A61C6D061934E130A71FE3B86F9094936CD
0AE972393C2F8F16EC677DF8BD2B478FA7BA2ED344271D172B2C9946094667D3
A43BD147653A2AA693F12A4F97CE50A32CA00972992E3014FFFA3D794E5040EF
8618A324888D5BC440A2D23CE5060A2F6C62D9C36EC5399E9C463EC70B57F20A
9445F8BA20628A84865B85ED7C1754CBABCC25B13514F7FEDAFFBB27F25A0FFC
0A92B651764876AEF8D409D4A861B519948F0086DADD88759213B6A7F69C2257
E265C9ED43AD26F4D070BFE743BDA0680216C0370D204E1B027DDB0E97586847
ADB1CE6D8BB8F5E3CEE7F267B39C6BF4253078FA2C735AFE7FFCC6ED4BE6345C
C7444154BDCE2324BCD0D8CFAA9C59C52E214F2AFD0314CCFD6A15BA124BF025
309A2737B8536F6A589A855A43C4B4FF3A9B9B23D563C04C2531B5A5AFB53AAF
5F2D6BDF8784A7AA1F352F9350FAFCE77A3F434FA0D6759EE449E06CAB42ED2D
7A9572B803EB99441B5FBA812085C40D5F0EBD3D37CBD8BF22D5396AFBE71771
058347F3DF59BAB07B41F7C2A0ECA729FE3D5BE522B30505D06BA64B99390D05
55B79E59C41DABC6FBA9698AE84300DE70D7E9E2249256C00569BDF0F1125E52
3DA84B28D87F8FB7DD6942DF64CA9809AFB91EF1265D50F64B1A1F5B66300039
00ABB4B4F05FB2C4DCAD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:46:05 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 161 /minus put
dup 163 /multiply put
dup 198 /equal put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735FB6B8836B8B5A4D2AA84
96C5E265C58458246B1452B308A022655587FDF933817766BE8A1E6C29DC4365
DC1ED202CBD81E0339EC4C3C57B054EADA2C699385B3CD763CA06787E96684BF
86F7BBA7009447D8D50167498735295CFFA5358D068EA503BEBC2D3A7EEDE760
BBC03394A6B01B1AEC021C9F06834D1CDE5DED19A5A1F909707DD8E695DFCB39
B34B86F032A4A6B240502DB75B72BE9D700A58634D640FF97B71DAFB8AB659B1
338FEC8E10EF40D16AA1097E862F3B82461B9DB20AA43C33DEB7513BA34D41DF
2A3B058E6379ABC7183DD8BAC1B00408934B45791A9004F3045C4614563A89AA
1CBF2EA03360BE2280462BFB72E1097A0D02D4F62C2D973C118AE83D2923773D
BACFC9BDB8E0E69C5DE89090F0AE2B0B9D954F1B4446A43466143C9D279E0A55
61F967CA3474A9B7A277609FF6B0E9CB97CF1751C2030D2BB9C6E3B552FFE4DC
67C7186B5714DF5E96F33F79A68FAE3B9FD0C2390C47C55D302DB20117B73C12
97DAFAC6CF9A784D7C6A3BE919AE3336EC0E9B4B456D4BFD2932F65562DE60BF
CFDDA90A8A31CD66BE1172E8EA3839223803CAD2C35D30776B13D3A8832662A6
EB8D2DED4537DB61737DD813C293785BBBB15D960552B24024FA0CDBD8990C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C5A68EB2DFA8D4DD83DE61F3DBA36E97E3B9D
03598A007ADF0105B16288C6DA4E024850CE068524199B057DAA355E4536EE0D
736E89C40EBB32B4A86D360D5BFCFCFAD31C18487F931AB032487BBD966F0ED1
8D81410F813119C112B5BEFCFB76101C07F53D05B8BE04D971C724DB2668731E
96F301B6CC25D531E86677AACE3EA3A91F0CE66E21D7084346CD33CBF25CBEF5
D472CB4C7650DF6FD8B3B31F630AF5107AAC6C8EA23373D0BE06E4C1188B7A4F
E59DA23C2B6E2E8E94CFB4A81105C648AB572C4998ABA63A89989A282337B556
2C601416984C2ED0A887B5BE606C3882B8E6E927CFC26313FD9D352D3A7BB065
9B58D13BBD84E1216C8926D2CB3CE355D958E1FE80BC9701C6ECBE840E637E64
C347CC94398B881FD0AC49E530DE619BC49A5DD9F91B4766F06D0F943CB8861E
D69DC71DEAB42CFB71077291EA019468902186EEC417AA6A483E768886444090
2F283615BA3755E3944C8D5D5408531605BD13EBB44A71F76248B694684125A3
870232C3CCA4AC8DC1EF163019E6363883EC4892F625C6CACDD72C726E008744
F8383B33D234761DEA8497856BDA04DD10EEE7043BEB84C62D7B46A094EB3699
CDB1A9406679EAE94F1F933DE269C7AC15CFFBE660FC1E5A4758EA23EF14001D
4F6FC6FB27FFFD254B345C3C32CD7F70DAF4D48F9516794CA4BAF0827AB41309
AD1CAE4940E093970991AD11C5A830E17A51EE27F727EBBD0411E3DB595FEF8C
2501BDAF0235FDDC02683334FF508FD924B568EAF96E7344A56505D616F0F3B2
0F3DBCE8698ABD5DFCCE5B0C401638E89429249EF111164E99A03A35925BA293
6AFB113BA123BC143E5E15BAF95BE6873697845E184DDDB6760709182967543D
7D8C43583DFE4D3F80627CFCD3E8BE1D7656C518666BA45A27055C773B16ECB6
511E2A60E0B185CFB488D118D74E8BF9637F0AC7E1C1D9184DACA06F816B12B6
478FC7ED76D24953253E0B2337E08EF79784F0204E1293F5E245E2A639E0BE14
4B6FCA0783A8D0377B11087373B6D4094FA159335DFF314AFA6117DE2564D95B
D8A43D0D6AAAB067235908259066D11DA94413CA311EA42E5D2E35ECC22BC5BD
0404FC21FFB7511DE223A090A7AAA99476382AA90F69ACCE6192E45DF1F389AF
BC623F91A309F7ABCCAD137EC3449FCE08F3DDE316796C192CF6CC91C45BFD28
131BBD91387BEBD327E67EEE2AA8879BB14C02A1C17A6E747D024BF19B4631F1
869F93CF571D4E1C1F8CC5DBE1FF1028AE971AAF5FD70FF4423F9DC9A0950A2B
0B48CB7824B855AAFFFC600B76A4E9DBCEE8170E3E5917A2FD8B73CE7080A142
BE0A1AACB91F3029E27BB62401142B171E1AE716B7F2260CCB88476E32DA4D54
4EF671B66930A084B63EDF20590A9C8CA124D1254734F24C422D8A98D5A956D6
95860B98050A8C614BF0BCF9866E9FAD1D8068339EA64E6392B51BA9F1730452
A8FF4ABD82A18D496878066CEE28B579D9636B62813D644C2A4351F69F9E0977
7C26C5587E05DDC8CCFAFA0C1D5E1D35C64C2AF35A3F992478D62CF47125D10F
B704BAC7D7F31682DA02DD3878C3BBE529B1E8318B4DE2EDB160D6EB534DAE38
D59111FC848C1F9EA3424019C6FD42BAAAAF50F3310B15BC25F73B34E36223D3
6412F89EAC607E38D9202D4E9909EC59F45EF050CF8B48FB70AC3BC3152B2787
5E87F8C5F58C101D404AF36706658418710D30E92B12BD6C7529114FDD325E6C
DDFC00D98E345899E3AE00C9010D6CFDBD82D34A4AAE8A508BCD611CEBDC06C0
47FFE2E60835E8E542AD662D6BD1264C174FD11A6DCDBC9D4398BB4F1F80F49D
7183066D5AB317FA4975A7827DF7BE1AC0711A55C6C0DC0787349A1CF807F910
998AA28D2A094ABB1A7C14D3ACFE8D0C446E49ABE4594E378F7242F1A6635885
65A9AB65BD1B40657C4251E2B37CFEFEF365EB09B823A085BA2FC6295AF61B46
1D535448C20ADF8549D820454E7C726E7BF2884170E6EE63CED9FD9CCC45FC80
7C0AA3A095CB253A85892810D52DAAA8B7FFADF2F6FF173F2489F4F8AC7FDC88
3E15A59673CBF082A6FAE822D4A177BD6E221B02B0A53FD398C457EBFE665863
AC03E8F8FC63B1BB85160C2D271301A8EB4045DAD639FF362DB7F4DF3E4FF784
221A4882C0D66A425E637DD44B4F6EDA30949D209B9141369E19912D6E53B350
51ACE807262DE2A9F4AB64E7117233A013D7DEDB5C3C24A911062FDF06DA3A29
F1520C13DFDA4E1DA7735C1F44C5DE4D52F4D7BFEF550E5E7E677064C370708D
8A505272289614C260B056020FAA6FFBD5035EA3B088A8F7D89E6F133B5F1239
9AE9E99E3444B38AFAF003A9B654E3FD123CA0D004E35A76916CD402A087A63C
FA6D246D27C7C1E5331EDE1D256FF9653BCEB2A2A3146954C59C5EF6BA97D759
7B0E0ACDF45491182AE55C1822481EDCB083111F0CF0BFC0D0DDE7598A3A8FEE
0B4BA7F82041E7514810F46890267C931709B495BD99B81B1E5F95672626C768
49D33455B99410AF1FB6B20F3D92C93AC1EA1115846E04A5CDB798FF3B91A98B
0AB95050E2775C6F58977BF2C3D398DFF53D95F87F1ACFC23B060FF2853B2471
F38B8F709A6E0F41628709E5A3F72126EA49093E6E36330C689C1F70AD75964A
3FE33A02F7E1CDD15228CC5A6B8706EB7C7FC39EAB89DDDFB8BAF2B4493D2BEE
D31B0C7C564357C31462CE7D1996BC95ADBBE87B207486758AD1FD1852339A38
D7BCAF53C9CC1F092EA5CEAAEAB476C7AD0F22F694A983C4FE7509053FEA870F
6E7588FAEF474C709515E44AC54B45CD2A504AC3D38B85A7B514497C2004AFE8
C5F62CC0DBBA9A9949B69AC94FE556C9257DA9673A2E314973C65274299E179F
218DE5E3610D9F0A1CC4D8725C47DBB1BB4F707B7F39737E8C1D02FF96BF578C
1E9E88C91FE3550287BFECA7303B0C730B0BA8D93838E918CB0B60438C3CD0B0
96E85F107227558945379392D74A667E2AE448323DFA8845137DD0D06E456DEB
F3851EC180D649E80D332113F6299B9966FBA14324275AAE2770910EA7C09E60
7A1105E5C03C1A0FBF80D6DDCA23C470C9706434B12A778FE0D9EE43919CF9FE
79DCE3B89CA7B5179AAD99C416D7CB53957F338E4294EC0991B3105870D91AFB
0520A7858768829E65AFADE7A779272E1ACF3E1CC06CF71DA1923BF6DF3D26F2
4E9A6836383668D0FFC9CC45042968A144019E813AA5417317804678CFABD1A6
D3C997441F5B4DEFF3BB7F8E3ACD299CF5F46587C661F589080FAE0120EB1B3F
3CBDBE51D264798761C4DC000AC12460C4B0E893454CFBB926540BD2D435D09F
F870058252DE2EEBDDBBA639350D7CD1CEFF5E356FB7B1339E01F48302FFA68E
53A58E891A63BA37F9030C81C1F104A9638E6AF6EB36CD27175A702DA1EB3105
E59ED9BE05173DFA3E581A994C41EBA75D41C78BA513A6C11F527B790BD67674
5C88D173C2BD05979DF757694CB3ADEA9416411EF489EEDC4406ECCCCC8A9A47
D8619ABD2E80781AFE5496CE73A0EDF0957CAEDB9EAA8CBF528BBE3DB333F568
D6FF61144F6A9E631538416DE2785C961B7CF260DF0DF0A794FC19FD3B56AD11
71ED3C5746FAE249784E23628FE96F7F035079DEF7342F83CF1FF75E0BB00ABE
35D1D5308C9249A8191F204C5F2228A2E8C6A35ECD167E327C8D51D77BF22A3B
979BEFBE98B506FDA19C1166890D3F5F56DF4FFBF19FD0FB8F64E51A6F9256EA
BEF7C4CDE312B5F73CDC4331A9A9A566EC9482310ABAF71573348D9B26F2E26E
FC0C4B6EF6E8E5702A0BCDFFD9613AF2EF5E1A8ABDD1A7897B154631AB5BD878
EBA39E672153E49DD66D3B0D54F65A54B16CD1784AB514FAC0CF8B815EC475EF
F78311CD6EC0E3E116E0E90E6199844FF84BF5939A9F906FA78E522495C05D86
54D1D5506A00090A973861A9BA29527F333B81118510A068600F85CC0EC17713
8C4D3DD55BCC7ED1D902DF00554298ED4C5C0A25847F2176F4F8A14CB46DB0CF
1A8353E73F5B8935E8D6E828B1A338B6F876D73AB1D963FAB21D5E44574E6C1B
E109392D39AD1AB2CAC1ACA70D25766949D361694C198542CFAB9D7E997D0D00
45E09059F1AFF608127EA1E09D426E35F195218A804B14771C27251A57EAC20E
8BDB7DE18B9A1E9FE0D796AA4A74877AB52074528BF856DA9AED44A912B6F9DD
3C20B9FE9F780D0591773F02CA0342C13AFF732ACCA93808E163160EB72892F7
3D69D0262CD10AA45C6764B7B53EEEE5444A3921BCA3E9D4B61B6A2C9887A5E2
8267C80C7AC68C3E0459A8BB210182797E60835A464C530BEEF479C8B1F92DC4
EAFC2F7D6D45D590A53A74C1813C2348C397319D751E95979877DCDA412F518E
D45BCDB8AB364B62A53ACDF95BA4F0C1D12F27C77CEB75BD87EE6B2F2EB74E99
6FBA581E7207A071D309C7CF0C7C4ADA4D01AEB289A4D78CADC41D981591BB47
1640E8A76F5DEE70F5C28425FBC17947296589E0A6AD4E40D06D7FE4A709E7C8
3E409DCE071777AF37B384E23D03FEDFE7F7544C948EE5561F6A8A357FE35939
8F2D217603B54313ED37BF3CC358375EDB3B1EAE1348D1FD783535B2C468C5DA
27861B5625C9535F2F288CE75AA21B3A8A019ECB95508FF98E34109FA661F4D4
8AFE017DACDF0445995D4CC6CE9D649F9B7D6F52481694A5BFF56FAC6BD37891
2997CA884D430ADB1F798605E14D362B0096354B47F75D05CE2DB3D648918F1C
E87D4779ECA84E04D1297C6FC49DFA01C4A6A78E59C7C254488893950B2D9A7C
14479025C94F55752CF0101319B6D14A376C398EF4AFDA5A407C6A34956E39CA
3A440DB581FBFACA961F03D1762A8E0AC324DEB5610D35F90B790D883B0C896B
05D2E05DE8F78898E722BA69A270D37331AE8535FF4EA4B2B403C03633F2D53E
E26B736A3EBE9FF678F3EF427451F225382A28319378A1DF17F2DCA78E9B5137
2DDB97AB64CE8CE031D224691B68592D54F4C9C39ADF1F3636A2B94B7A9DF5CF
6F23FBE43812AA0AB34BD8D1A690B62C70F185D812569F69960B850A764ADDFB
AF8CCA05967CC58A0CE618C75090931A00E9468654399362FBDAD6ADFF67656F
BB6D50B2772F4BCE6AF00228DD0F4151A3CF5FD03228694AA1E61C535036C8C2
78A4AD23F3FBB3CDE8FDDF7062E427277CBD9FA34500F72B491DB2565E849E3A
438D691AEA39EE8488638D7C480FBAB91561D07A32EA632FCBF9146D408B5A14
02C2F6D748E35BA031AB3D1B5CE7140D47EEDE16EAAC10164F7DF718E0EFA2F4
67FAFA61AE0927F3CF2B91CE41E565D115026ADFFE7055099756B237F8ED94AF
22C0B6269D49C44C91105A123C653EE797B8EFDEE186A034036F4A7D1A6F8671
1419C2B017E2A2F71DB6E3093EDE6068C67A6F2E6497512632C4C443525D0FA1
722D77FF400C79892A5294EB9E8F78FCE0E17688A58F4F89ED1837EC6515F661
058DBE39C56695D05A94B0CD715FE50EAE89EF8D490F9E6863CBC21192C28FAA
D5254167A21DF3C03D66DCB01FBDA0F71F4DF0A725C10A8C4A879CB19CBBD470
377584EC272A85F97D118E0EE3E998EAC0F7CC4E778967A2CD9E35988FD58AFA
47A599EFB80F965E8DD6E7D8DDDDC9CE4C7493DA726A73053892620BDC00FD21
1DC5ECBBBFCB7D5E29DC0BB42EBA51302C8A7C7179D6704B4308A3727F5615DF
52524F9CFF9EE1217FD3DC31B8A50063EF09DD48288CF569A93E0F876BE2982B
ECA625CC1C5FC39D549089FC76A7E738BE964443632A64DC911A05B7E225413A
DC7FEEC8FCDC2D6B7DCE10CC80CD098D1EA42F31F29C281C201BD2BCF938F2C8
ED6FC8001DB35B4445CB9C354D016311B33EDD58007A333E41E6D0D4F2F93797
E81EDB38F06D7821F77CC61260CF2B224FAC5E77FD4E222342500A28D9693822
A586932D1B209938DA2463A4220CB07BB79F19980A2F726DE7466000FC4CF71B
756757F9558FA7668CDE74E37C9AB7C1B18967E8E6D308F9DE7AC346530E9159
0635EADD3009E6DC9C9EA5FC93E2151795331A7A2B629F639A235077EF740D32
B4A2E6B46D891228151255A190C66E84E04B0D6FEEAC5972169D14BA643DCE6A
8EB4E0AB0255E4A960FA658D6104DFA5D75A5B34BD7C03CDDEE4DC00372530CB
B538CAB184E3843CC75FCDAA409745A93A475EBD58A90B99858B67EE6EEBC67F
9081B067CDBCE3F589B96751956D7684F3B1EF24974DD6B038DB0E2BFEEBB65D
AC90EE2908A5E1758B293E6B40F38FC8562EEC0FEC96F442C25324CC94A37ED7
FE053CD1BC4E240AE0E560FB40386ACAAB956FA3C7625EDC04141878557007CD
27DD60794C189FD65D864ECB46C1915B6A73D8FE9B08C97C73105EAD1D89EE81
C52A1E6D7F3FED8589B8AF1F77AC6E99ABD6F2B63BECA2E08DB5A22A86ADE0DA
DA68BFE298CB7AABA58E0D9E6DDD321D52556209694315AF1935F1DEC712A6FB
34C62EDED4AB1BD49A1E25D61F2E8A5BC5FED4DFF7B8875FF41E014DB400BD9B
0CE8CD925DDCC2EC214961DF4B4C68564FEDCDDA7BA3E2154BFC9348A6049F08
2D1590514B196B93A337C2182BEA5AD2C4142C950FB6F4E4F6E1590F35760D5D
8D960A2E3E913CC7DDDCE3D915F0FC9E5C7F4405746CA718989D915D06F871DB
941811ED3EC429C128A05C49ACD326A76B012F5925C5DC14AE085785B9FACCEB
F3212BD35164A1E57EEB777539728A672D11B84618158EBAAD27211E8658D46B
ECFF536A950B6935D7F1E5782C12D2FBEE0AA452F417D2751A787AA3826435CF
B2CD64CDB2EFD7E802FE062AD9F255586C4232A1A6CDA1B6BA77CF77CCD09705
92075BA1DBDE4F8DA06211DE163DD6384503D8020CD260447A607CA2C24E11C1
CB836D64F1D55762FD3FF5AEF574419F8115F2BD02AD4126F724A58E8F37C083
2C40FE6109D32C22793372A5512AD1D04AC9C488F12EB5CE8F5C638D06C4F9FC
142E9406B8B96E0E045835D200AA6D8EE6B93AFA63B584FC0C31C31699283312
E91CB9F50407BC37AAF47D14E425164A9843955BBFDED2745418BEFB86023327
4229DB7C80417451475CA0D6EE1B33BBF1B8EC13EA824FCF86AC97514ECCE839
C7B0F3377F3F3693EFFBD48C222F664CABD1FE1BE73D5BE82AA9D3E200EA9F5B
3DD2F852969596B40A2A84C9B61428B5E526C9555315A50CA60AB2CF44FC694F
6EFF0608BD00BB3C438C31DCA9696C2D1DBFF57567DAFA80CC7A5334AB94CAE1
962C945266FDEDDDFC404BB860B6AF4B93B9BBB598A4AA4E2F3134A743C0DB3D
539A8134C4E8F496AE4F530A6DFB4CA6167C83D52C161CFB4C29E4831279BB5E
4BB48A30F858148DC9BB9F424788C624B13FF232F972C1D4360275D88A214BC3
217297A0E4E422289B07904E2B75077CD369891DF50B562424FEF636E154E4DA
66EE0CBF5D6E4F1272CA620B295FD695F061EDD9AE0EAB194229D2F9F2FC88C9
B11F640CD3A21878AF0758470A3B7EAD188847E1D95C93C6DFE11EB3122E379A
00120022F84C48B07F057D764CCF2C1C4B70176FDE0BCB0C3E6F1A9864D13A67
F7E35F907F75908ABD4784844333FC9C6C59CD3EF1A118FDA392ECE3E3A0B669
50B3AB137F6C030BE3732916FB7DFFD3BAB23600C989FE467AC4CBA22989B5EF
3242B4017C11A63306884B12E05F26AF891E3B72DE4F21B75F5239E014E09FCC
5BDF6988A14CC90432386E51FB9A5ECCECE74E82B8DE0C0E50862DC4C097796A
04EA0FB8A7A0A481E38CDAAFD581D4A22329A90DA079B2CCAE35227CB580EF72
84BB2B3B7A69483B2171F83934FBFEEE44919F5805238B19A2FA4C20D4910BEF
23C20DA932BFA4FA7BD56B3653CBC183CFC660D8886972A43B5FD6AE51F5040D
CBBE902ABC9494E3D850852D45540E911E023A45481EB02F476D6A29879B74C2
3700286DAB56E320C1830B83A6558AE7AC6127A68E47D1DC55F549333DDE4C9B
F03B7050D34590868235D05CEB392343F8AFEF797890A02B36854D9C26D063BC
5C88FD766C21AB2C7A939A4E5E7CB9F8B6595B6B7D26BB45030171081F0F1CAA
35E81ABD054D492CB02DDD7773C8F1C0937D279C63519D51DA3AFB1359607DB1
5B9E4A65AE3284E798B768802E6FBBDF0F8EF2F3861E0BF479BB5CBE06D4C64A
362EED6C9CE91D808BF3E4FA654FD11DF800BAC939F881557200C80A7992D7A3
DC9FD2EC825D99A63C68C48E471AB4CA590C30026075AB0EC641350D1EFC9F8D
7D998C3ED886233B30CC050D2A3CB1E7923FBA3AADA69CA1ACA49C11077BBD40
E945D64695EE6D10DF7E43AB66E6CC6932B974E27BA71C9F5B48C9D0BE4CB537
E45836B15BCA98E1D317D9072940EB7B12DE251C091D5F90FB0C1FA5EDD72E54
F888AC43076AB1A6AA77D254381349D228843D20F3FF4B526C85000C34C7B6B7
476855D0E4910910FD9FFDF38260524C220BCF2327C8BC154020B710836BC4E9
8706A411E10577B68FB5A1CE869D5DD9F91B4766F06D0F943CB8861ED69DC71D
E98488ECE43C40E2462B33C7166045A7D9E75451FF11A29E5D1A18AFED9719C7
7E1FCF02A127928B6E0892CDB2F9D59EE9A0C092718F86762C17C3DB7F50C4B5
11C0C44BAEB2FC46E42FA6AF130B73EFFF935B48590E824A101D1CE220C00C62
434E27AE9DAF3B72CFD1F54B876DD8797D28785CBF0687D2FB499D69F12F4CCE
2832BD989259DD7D1376F31F97FDA0678FB65430FAE246F97DD10CF7FFAEBEBD
B62AC51F0008AC7E75F576A9E03C2096B9AFA7DC3D573081E9B2009EB67D0911
C952FE14918D8AF58E75782EC966475E3C01A103657821DA8DD73337AD53A0D2
7431B1D0E6185370CF20716B559A93F9619B1D1B79E8B8B0C0C4F5D74DA9659B
97166F2C9E9F29232FD73910FD8535A68E1F37318B074F364051BFCBC9A2E58D
83B567538E369719AA1383ABD7A80A00321FC6593EB9C36F003899EEBF2607BE
EC3532F4191EE1770A9AA450AB633E094E1BA66CDBFA82F3DEEC117B7B970FA7
3FD822026854C076DC7279B83F9321558D70B55787968955BE362C7112994F68
FDA03255B9ECFB39FAF51D0CAB9A3DBF94929B68C05578ADB2F5168DB2F5AE06
C0253BFBCDBDD64743F6687473EBC160B0436A5A834FD063BEED6571E7F76CFD
77016998FA1B157EA198D13E4183912508917AF0C054252EFC5A75378730AAFA
176C4B7B53FBCC031BCDEA7664A00CC8C8BD1102984EACA30C61CF12EA75ECB0
DE30DB43220FD0EBFD1598DA057A876FB36D6A3AA28263149B71CFC7CF01CC66
4A3DE9436CB7B1D72EBD81EB49AE59951B8C5C02448AEA20B645B729A0ECBF3E
4367521534BA4EF9E75945BFDA83400BBD6DE23131C4B4967D546FC1EB523E20
BFB289D6048220ED53F1C407397DC111E36130EE8875B34AB847E65112C9B6AE
7C3597A1F20DDDC374C2E9FA51041A5190BE004C4AC6EB7E3C8132122BB2CB3E
8B92F3A5800FFA5E094864E25D63AB008AAC32B7F65A47E876881C2980579473
EEB84FFF6200BFE125AE60FBA48F8E7D91F8E68EC3DDD08CBF41426B88D07493
0FF8B5115B4116A0DFFAD8C2C2F7EE08EDE1E3837AB4777A6DF254E2AFEE1B4B
AE7EF27586F8CD173D9719F123892A76C60EAB7E25C116766AC319CAFDBD8D7B
48C7AA731EA9D47C16825126856CE5DA669E5EC92AF588B32A87A4DC3C39404B
5E3381B62D0FCED5F34F0B3A5A934568C3065E55C77E2530A673200387E00F6C
C85C210CE196F4CD08E03841BB3DDC3172FE977CC49699FB8FECBA9A806FC727
03DA35D68D91E90C7547267FFD6B8B13E1BEF877310709648C126F4711A28202
780863F3E2877AEF0AE5F49E4A061FC1431FB7347F89B403872375F0733A9841
07090BF34BC4CF61DD6137AFD40BFD7ABC1958A59C45C76FF38DC732191ACD49
DE1DC7670F5241978C29DF6D599382AEDD0BDA2953DFD55558ADFC1F1BF44444
F418AFA8A577304663F5C8C0A2689D828C7C15E6503D32BC9D07521DE30F8094
1185B62F9450E54B7C4D0C3A36BB8794A327C8D7EE61D7DE5B09A07B0E0C08A5
5054CF6038E3FE3106162A7E04C4A3466D34DF751C447975F5536A0FDA0C3F11
E3B29A35B34248238B4357A9CE79A45FE1410F4D901B9CD23456AC3D4C879EEC
FAFAAE56199825F0D9061BB173A54669FF44C8BAA9584F49C478C1B0A6273004
256A617ED888CEF8DA19EE3BBFD85FD25296691FB3921166B356F102BB902842
5F71EF66C3D262EFF1951E10812644172B83BA6D010A596C8F8D3DAD511EF5B7
E6B0E8B0F5405BF8E7F0C64555B29ADB992C57D07A3C61C3DE82902CF91854D0
CF82A44CA3DA52D54D2D7299B3478A23AA236DFA8AE31CA876D28CEAE4CD7C94
26AB4FD53407B087EAB33E7578FFAF87FDC916DD8A23AD2C2B0B8C70D65C6793
3195EF5AE6521D41A117E690134A6BC3614F7E4C8620845E87B12A6BAB0BF966
3D82BA7CEF2A3E630C275CC4F18447490B82EE28271AAA9B6CB1D05B76FBB100
40F0E8D2D09AC4B8DED83076F553D7CD7134842D4BD222DBA0EEDE6E2A464F44
E7700751B10384439B38D63BA6A2F90ED6A01994A0A56234021B38562D903964
1275A7E33DA0671E12E05C0024A622FFB66DB183109E98D21F131F43A2805BE0
E902F95B9A86DC64129585454A5525C6D23C82FB2C05C2CB425936C5DB8AA908
ECC570A068826CDF85179BC2A6E3431FA9FC4EA7A254359C6671F34C4979A9D2
BABC00A9E85CD93F23F0524D9781A605881505A4B34CE31DC252214E944FBA0E
66BEFD41F70CFA0D75FCB3FDD65970264A25EEDEA56A74B9EBE7474AA1ED75BD
62BF37BAB6E3EB2C72F66901C1D54E6640636046DE8249F66FC9118B7A2DE8A4
E88D2F004F2858D1A89AD21A7F44DE68329855279DCC4489899E9F41A55F3C82
96E308BB2A159905F9C2A6D3F0515E6D8A0E3A4370FF84035977ED403B3AE5E5
638AFCC6540A55D1EFB34886D07FB2D313480A405C503FD8ACB1E2E4CF751D6B
86D4C7393770A1670C9EF387AF8C2F54724E58676EF638ECDAC4B896C64C44B5
8F9DDE9AA52D0E75655E4F9080E37515ACAAF0CD46E119B554F4CF23B621BFB5
48D4B63E570AA844DEE0C55AA8BC02ACDE8A3A4BFDB2AE879E7BEFEBA569758C
7132FE9C1D757ED9D2B58F203A3D2601CC447A1551FAC0D79F9DB3B51BDA3784
0C0C1CF3AF64A6F0A9CE4849FE094A5F96755468FC2C1968490158098C9B504A
5809102BA7126E8951F1E2AAD67F3EF93DB577D2D0F8635703C7E9DF1A1CBB61
E379648BB24DFCC97743FC27B43A9CFC96FBDAD1AAB9F58C5D6D3D3943042B93
9680912BE7A8943648EBD2463CB1D5F4BC78BB022514B0D6B96D3030D46CC782
41295C2CB1C058F056A2BD1E8ADA1EC73FB07A2105BF3561A628F8D3F9A54FA6
06B5DFEF1FA79FE1E56B1851164581BE8513C1B44D5734C6EB204F09D331D3C1
15ECE138BCE0D709937DDA20D5E5C7A25584F907D13A8CB13779616B828077FB
613547481E6F3656432048A0F2006855DC2B199CF790ED50A55D337F12B58964
83C9F6CADE6533CAC84DF5D4291448B15861CEDE0DC62F5D4932CAD33C777083
723CA636FA1947C8B6FCA553DCA5B641943E73C31E83D4113E9B91158E1FB4FB
880B9ADBECCB922433B68A3510F25690A5D28CC036A47FE8AC33AB45CAA22F6F
454212F4826C2F9675511D99155F9983412341B313BF0B6AFCD70A19C43CC59D
581F41B2E6DD1AA8FE90596CAD58FBF92629DCBA8D2172C3A649D7DE6E75151A
5223D1FF9BC1254E55A6455ACAD83351C64A416DD73025A18A3DC8F5CEB67EC4
910B836D56DDD467392771B2329C5A790B7E5146B69C49C35209778C04ED4094
79B9EFF2FD4A5C4D46B4105E3023A4DABC2C87D547AA1AE38EB626E996082060
EE975C6ED905B7584E6107086772F4BE1C88DE2BB999F2EF676B9096721EE7C2
146690FCA0DEE4D5AF74B03CCE61FD5F751098B89CF14A748711A850C0B80825
4A7A2C7EC4385FF06B1E33278D4D3415222B9FEC5FBC0932108E5E3F11D7F99D
A659E24D00ECA783F8CB93EF91C7A9FBCB26045CE0567C8619B79F2FE0693EAA
8CF113C46877A3F5CA472D72EFF7C235BE9F8F9C31AD6A28B5356B62F4D9E2C0
33D0CBB3BF509654D20BC7BB6ABB0648FAAB48058D312D3E154FDC8547DBB905
FDC3B053B9E909C64019611CC672794B6EA84BE72B3B03722ED035ACD8C45BE5
1CAFEA0A778E9F4441F4484DE336750929957850013FB3F1B04766693591F60B
0BFEB7EE0DB28578F81C2CA7776CE56C8FFFBC318FA03DADACFB85910DEA2559
43329A0C29A2AA4A7303C5135CC9576E27678241CE574700A037E4C94CBF1DAD
E4D2D5DF31ED23FB5F577C291BED2B28C6D74015EF12B2522F48346BF81176F1
95D563394C53301307C1C764139F03A4A91E28921CBC716A183CAC7E4625E549
FFEB8FBB596ECBA121403FA635269ABB794539E86275D6D5B91606846C29B6E4
F6EDA1D2B9C9CA087D16A8CF6B01DE610D5040508FDC050657898AE1E30084F3
A772AF419E77F36D12D0A7E8D27E500BCEF025A61578093E84870E99AEAE8092
EDC4603E0024A3A760C24DFD2DD7203A88B2073011C873D4D11E54E550C4866C
8818EC6E0271680574BEAB8DA66136AC4BC38279DBA91986AE0B199CAC806CF6
B34AF102E072D8F79369B8F696138FB2E28AEFF4B5645D9075CFBABA75CA3341
386CD2F34F6E980792E28FA897D120099B54F7996C45E36290C7ED9F9EE285F4
76035B2F99DFD64BF123CB7D6474B8857FA3329C777DDF2FC3AFEF35D7972DB1
BF7057E36DC67BE11451A7598B7C78882DAF87D6AFA1351BF786E818D17DE3CD
7EF73EFCCEBAD0713A55BE7E8A5A4D385D6FBFAC0894A63CF2D0B96E4299A1A5
634B3F409BEB714031B630E23846C9B8945EE1A4E414CEC5E59775795BBC0BA7
5E02D40F69B6726971370D92E5E2850159E0E58B6E61341F821DFD6CF967A7FF
347EC14E4C8FCA3E83C2CC920D51E47C22B2FDD9297E8187EFFC6F244836761D
D8BE4E048EEC70DEBECC4C2AC87A25E99AB6A4BB82EC83B52B32769ECB4675BF
4EF5869D212B1EBA074A545E9ACD3E0D50BFEB176D0B5DF6F9C6DCD72F7E2AD6
8A0BFFE832B867D489932AB2C971494D7FFC3790F6CBF7E60B8EF7BE1E8333C7
56CCF22DD0A05060C06DE4BD4B0D7CC058DC3547834AE7359B7F109AA2FDFD04
3D22ADBFBCBAD28B50EF7B324353D1B6B5BD89988AF5DD58F0FF29400D3DFE98
F98A1DFA59A884B309220233A8122C1C7FEC772E2F70F132AF03A5FF46D4E98F
EFAE8B538E596026B6C95030E402D2C3B8990B34213E3890AB00BA501CED98D2
F284D0CF1F60281C4885F92AB1DFF728F66E3E852FEE2227C74D16629C035AE6
6D672CA35FF0AA5B40C6C8CE850D9A1E51D0EC1FADD3F42AB6AAFBDC6CAD57FC
8F2E0C3364F230C9BCC44A617795587FDC2FDA04E930021C08960FFEC658C713
53F81D297A5C1DC55293ED0C4A015B2C600DED044B5D91E3592B8B6B87009386
E3E015126A3D903451F131D6F0CC2B6EA1F51122366254AE7726D1107ADA9219
9C37F5A25367CFFD0F74B1FAD95B9894674366AC4EF8AAA6B79081AD7EC645F9
3FD3683360CDC2B86B30CBE55958FF9ACB9F5ACB7547B8D114E8B302A3BA7E1B
7B095E58C9251D4155839EDB5A231B9D2415B02690D1186389F08E378D003687
E10CA20920429087EDF36DC4F5D0EA56A393300B111E4A0CB231BCFCE0F4C79B
5B6DF66CF50AFF99EA74C853E536A1674E2D0D28C54A870C5DD8A992C3A08D3F
E1D0D853155EBC68199C36B1B5AF1AF8ADEF917EAABF6544367FA7302E2E89DC
0BCC2972FA1AA221D8BCB0D9CCD85D69FD6C19BFB2DA2B580561C2CB01B94B94
96F146BDCDA103BF5142001CDDE9D85241A2F80BEA4FFEC42862F6F256531786
4F0DBFC0AB9F0396C14C341E46C457F68040AF78D03F97BDE35240C2FC197EA4
03C5709E3B983E00EDC12324FF91647607CB7FEE7DE7E36DE0AC32F07DF96A30
C53FD503ACEE438BF84E8C96BB885CFD204CBD44B6BB4C710E74EDFA21E31466
F6E20BC44AD7444540EB6C33451048181DBD1C70E39A463D11CA21C0489707B6
4D8B1A0BBA8D8442299CF9171AAAE2346D5C7404BCE366D1C3D024538C820E9C
EC45BCCAC74E781933A6E647D6D5129E932B9C19B968160424F251855BB021EB
15A49A2A426A8BFF21DA0F3669769F66BA659A05D6B8F8AFB3C9C8663E6A4236
57A09592ABB284B02DB637A3A8121E9FAE4B77D9A0CA73E9361473E23CCABF53
D4F4F9E06255F48A17800293533139741BCF65F8E58C8CC963DD1A4BB1D08EF7
534E68F8F85EF0E172162E81A2A7923EE143800F6EA8B87F82C6FA9742A780BA
6A01B3CAB2C7FF17B3A123BC44390A5E353DD0AB5BD4872B3A01B933C2A745DC
693D7BBC3C915D1978AF577C3981113B860BB415D5C7E4E0909CCE478E5A9DA3
79A17B634DABCA97BC128FEF2117B4966A67609288CABB4E90D28302304AB1EC
A3780407EC279ABABB94229FAE816D7C278E89A1F324E21D11D43F54E0A2D404
E3B1CB05006CC55D718996B532AA4F607177A1293089F85BD02DBB109BC105B2
2DDD3D6756FBF968A9183A1E35BF69B738F761046ACE1E3FE1610EC8755D76E2
6FB9D4CA2CD013AE7427DE9C03AA828D1F82500AC8AF8214CEBAF28D7D03580B
21A03E11D595FBAAB849D501BCCA386A362DFC2FA72C712B08A0F9A16D676CCC
02B58D23BE1A109193B3C90BB11A31319153BBF26A1B31B0A3770C3375787A36
E0F9935CAE7CD861D63327CBEC238062EE6B9F8E1370A079A00A1D56E0743CDC
343FC0EA59B57C8CA2AC70BACBD5434880D054D339DD1AE64CD94D8EE416C0F2
87D16B069A081F8400B0F650B6B3B01B916800C3CE99E19659FB44B4E2B03001
5BB2933C1AB1A39A898FC5CB68BBD7423EB6C5360B558BC67B67EF9A0A942F7C
1083F38F9ADA6CF585583ADB307CD3E279CBCC5F175591BEA8C3C6814302EA4E
5010899A595C1B95FEC125C129F1EE5B38CDD2DE683D8F3DBEBAB2A52A514D7D
1129859A067A61BB9AF861FE19F759F7174E3D16822A0C58CFB535DA00B973F9
3A6911EA0A9D4415F0128E6E596AC5BDB5E12EF7241D1CCC5546A34EC5296008
10D3E745BAE2BF7A8B8D1833EEC180D63C06999961811C78ECFC2920E0ADD286
738E8F72B1E3B2E62DAE3D1A788D22A1351B3B06E1311968CE4F8AA655D4F6B0
D48F85AF0B6B3F7C7E0ED0F482DCD6658065F7B9A31DF9C0A12099B99D7CFC5F
41B5F0566A58B6C20BAA3115F1E3917B5995FFAF50870FDB4C53543CE918FE6D
69DB165A88B0E37B077B395BE1037F013C404BE0F5AD087B2E4C3FBE4D845E0C
088D996A40BF30C4275D26673159A81C8BF54C7072510A685074B367E5026E61
2B9606975BE8F011BDE70DFCD14C5A570B5BA94E720D
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099151 1000 600 600 (ficheExoPS1_cor.dvi)
@start /Fa 204[31 51[{ TeXBase1Encoding ReEncodeFont }1
58.049 /Utopia-Regular rf /Fb 154[26 101[{
 TeXBase1Encoding ReEncodeFont }1 49.6466 /Utopia-Regular
rf /Fc 135[39 15[46 104[{ TeXBase1Encoding ReEncodeFont }2
76.3802 /Utopia-Italic rf /Fe 57[55 34[55 1[55 161[{}3
76.3802 /Fourier-Math-Symbols rf /Ff 135[40 2[48 28 34
34 46 1[45 49 4[24 3[40 1[38 46 42 27[48 13[43 43 43
43 43 43 43 2[21 46[{ TeXBase1Encoding ReEncodeFont }22
76.3802 /Utopia-Bold rf /Fg 22[98 118[74 1[116 3[53 6[98
3[99 16[114 1[148 9[148 1[123 66[{ TeXBase1Encoding ReEncodeFont }10
190.034 /Utopia-Regular rf /Fh 17[22 4[39 39 7[40 103[37
1[38 46 26 33 30 45 46 44 47 70 21 40 21 22 46 40 24
39 46 38 46 40 10[48 60 47 41 2[46 58 60 1[43 1[27 4[46
60 52 7[20 20 40 40 40 40 40 40 40 40 40 40 1[20 30 20
2[27 27 21 1[64 34[47 2[{ TeXBase1Encoding ReEncodeFont }59
76.3802 /Utopia-Regular rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 -354 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 -354 a 0 -354 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 -354
a 0 TeXcolorgray -136 -1330 a
SDict begin H.S end
 -136 -1330 a -136 -1330
a
SDict begin H.R end
 -136 -1330 a -136 -1330 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -136 -1330 a Black 0 TeXcolorgray
Black 0 TeXcolorgray -128 -718 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -128 -718 a -128 -718
a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -128 -718 a -128 -718 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -128 -718 a -128 -718 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -128
-718 a -128 -718 a
SDict begin [/Count -0/Dest (section.0.1) cvn/Title (Pr\351parer le DNB)
/OUT pdfmark end
 -128 -718 a -128 -718 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 -128 -718
a -128 -718 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 -128 -718 a -128 -718 a
SDict begin H.S end
 -128 -718 a -128
-718 a
SDict begin 12 H.A end
 -128 -718 a -128 -718 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 -128 -718 a -128 -85 a


-128 -85 a -128 -85 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 save

 0.0 pgfw

 save

 0.0 pgfw

 restore

 save

 [1.0 0.0 0.0 1.0 249.31029 34.07811 ] concat

 pgfs



 0 setgray
 -128 -85 a


 pgfr

 restore

 restore

 save

 0.0 pgfw

 save

 0.0 pgfw

 restore

 save

 [1.0 0.0 0.0 1.0 249.31029 34.07811 ] concat

 pgfs



 0 setgray
 -128 -85 a


 pgfr

 restore

 restore

 save

 0.0 pgfw

 save

 0.0 pgfw

 restore

 save

 [1.0 0.0 0.0 1.0 334.05025 67.83875 ] concat

 pgfs



 0 setgray
 -128 -85
a


 pgfr

 restore

 restore

 restore

 save
 0.4 TeXcolorgray
 save

 0.01 .pgfsetstrokeopacityalpha

 0.01 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.02 .pgfsetstrokeopacityalpha

 0.02 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.04 .pgfsetstrokeopacityalpha

 0.04 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.07 .pgfsetstrokeopacityalpha

 0.07 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.11 .pgfsetstrokeopacityalpha

 0.11 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.11 .pgfsetstrokeopacityalpha

 0.11 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.07 .pgfsetstrokeopacityalpha

 0.07 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.04 .pgfsetstrokeopacityalpha

 0.04 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.02 .pgfsetstrokeopacityalpha

 0.02 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore

 save

 0.01 .pgfsetstrokeopacityalpha

 0.01 .pgfsetfillopacityalpha

 4.25198 68.15623 moveto

 166.20811 68.15622 332.41245 68.15622 494.3686 68.15623 curveto

 496.71695 68.15623 498.62059 66.25258 498.62059 63.90425 curveto

 498.62059 4.25198 lineto

 498.62059 1.90364 496.71695 0.0 494.3686 0.0 curveto

 332.41245 0.0 166.20811 0.0 4.25198 0.0 curveto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 closepath

 pgffill

 restore
 0 TeXcolorgray
 restore

 save

 /pgffc{0.62 0.12 0.39 setrgbcolor}def

 1.0 .pgfsetfillopacityalpha

 0.0 4.25198 moveto

 0.0 63.90425 lineto

 0.0 66.25258 1.90364 68.15623 4.25198 68.15623 curveto

 494.36862 68.15623 lineto

 496.71696 68.15623 498.6206 66.25258 498.6206 63.90425 curveto

 498.6206 4.25198 lineto

 498.6206 1.90364 496.71696 0.0 494.36862 0.0 curveto

 4.25198 0.0 lineto

 1.90364 0.0 0.0 1.90364 0.0 4.25198 curveto

 closepath

 gsave pgffc pgffill grestore newpath

 restore

 save

 /pgffc{0.905 0.78 0.8475 setrgbcolor}def

 1.0 .pgfsetfillopacityalpha

 1.41731 4.25198 moveto

 1.41731 63.90425 lineto

 1.41731 65.4698 2.68643 66.7389 4.25198 66.7389 curveto

 494.36862 66.7389 lineto

 495.93417 66.7389 497.2033 65.4698 497.2033 63.90425 curveto

 497.2033 4.25198 lineto

 497.2033 2.68643 495.93417 1.41731 494.36862 1.41731 curveto

 4.25198 1.41731 lineto

 2.68643 1.41731 1.41731 2.68643 1.41731 4.25198 curveto

 closepath

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 255.12138 59.6522 ] concat

 pgfs


 -128 -85 a

 -128 -85
a -128 -85 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 save

 0.0 pgfw

 save

 0.0 pgfw

 restore

 save

 [1.0 0.0 0.0 1.0 78.92885 8.18654 ] concat

 pgfs



 0 setgray
 -128 -85 a


 pgfr

 restore

 restore

 save

 0.0 pgfw

 save

 0.0 pgfw

 restore

 save

 [1.0 0.0 0.0 1.0 78.92885 8.18654 ] concat

 pgfs



 0 setgray
 -128 -85 a


 pgfr

 restore

 restore

 restore

 save

 /pgffc{0.62 0.12 0.39 setrgbcolor}def

 1.0 .pgfsetfillopacityalpha

 0.0 3.25984 moveto

 0.0 13.11324 lineto

 0.0 14.91362 1.45946 16.3731 3.25984 16.3731 curveto

 154.59785 16.3731 lineto

 156.39824 16.3731 157.8577 14.91362 157.8577 13.11324 curveto

 157.8577 3.25984 lineto

 157.8577 1.45946 156.39824 0.0 154.59785 0.0 curveto

 3.25984 0.0 lineto

 1.45946 0.0 0.0 1.45946 0.0 3.25984 curveto

 closepath

 gsave pgffc pgffill grestore newpath

 restore

 save

 /pgffc{1 setgray}def

 1.0 .pgfsetfillopacityalpha

 1.13385 3.25984 moveto

 1.13385 13.11324 lineto

 1.13385 14.2874 2.08568 15.23923 3.25984 15.23923 curveto

 154.59785 15.23923 lineto

 155.77202 15.23923 156.72385 14.2874 156.72385 13.11324 curveto

 156.72385 3.25984 lineto

 156.72385 2.08568 155.77202 1.13385 154.59785 1.13385 curveto

 3.25984 1.13385 lineto

 2.08568 1.13385 1.13385 2.08568 1.13385 3.25984 curveto

 closepath

 gsave pgffc pgffill grestore newpath

 restore

 save

 1.0 .pgfsetfillopacityalpha

 save

 [1.0 0.0 0.0 1.0 9.63786 4.86147 ] concat

 pgfs


 0 TeXcolorgray 0 TeXcolorgray
0.62 0.12 0.39 TeXcolorrgb -110 -85 a Fh(S\351ance)18
b(1.)91 b(N)n(otions)17 b(de)h(fonction.)p 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -128 -85 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -128 -85 a


 pgfr

 restore

 save

 1.0 .pgfsetfillopacityalpha

 save

 [1.0 0.0 0.0 1.0 15.5907 27.9544 ] concat

 pgfs


 0
TeXcolorgray -128 -278 a
SDict begin H.S end
 -128 -278 a -128 -278 a
SDict begin 12 H.A end
 -128
-278 a -128 -278 a
SDict begin [/View [/XYZ H.V]/Dest (section.0.1) cvn /DEST pdfmark
end
 -128 -278 a 0.62 0.12 0.39 TeXcolorrgb
0.62 0.12 0.39 TeXcolorrgb 0.62 0.12 0.39 TeXcolorrgb
269 x Fg(P)n(r\351par)l(er)42 b(le)h(DNB)p 0 TeXcolorgray
0 TeXcolorgray -128 -85 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 85 139 a

 85 139 a 85 139 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 12.3847 50.56694 -25.28346 -6.19235 pgfe

 gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore

 newpath

 restore

 save

 [1.0 0.0 0.0 1.0 -22.36137 -3.24039 ] concat

 pgfs



 0 setgray

1 TeXcolorgray 101 139 a Ff(Ex)o(er)o(cice)14 b(1)p 0
TeXcolorgray 85 139 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -128 280 a
SDict begin H.S end
 -128 280 a -128 280
a
SDict begin 12 H.A end
 -128 280 a -128 280 a
SDict begin [/View [/XYZ H.V]/Dest (Item.1) cvn /DEST pdfmark end
 -128 280 a 0 TeXcolorgray -26
412 a Ff(1.)p 0 TeXcolorgray 42 w Fh(C)o(e)22 b(n)-6
b('est)24 b(pas)e(une)h(situation)h(de)e(propor)q(tionnalit\351)h(car)e
(le)i(gr)o(aphique)g(montr)o(ant)h(l)o('\351volution)g(de)e(la)g
(tension)i(en)e(fonction)i(du)80 512 y(temps)19 b(n)-6
b('est)18 b(pas)g(une)g(droite)o(.)-128 562 y
SDict begin H.S end
 -128 562
a -128 562 a
SDict begin 12 H.A end
 -128 562 a -128 562 a
SDict begin [/View [/XYZ H.V]/Dest (Item.2) cvn /DEST pdfmark end
 -128 562 a 0 TeXcolorgray
-26 678 a Ff(2.)p 0 TeXcolorgray 42 w Fh(La)g(tension)g(mesur\351e)h
(au)f(bout)f(de)g(0,2)i(s)o(,)f(la)f(tension)i(mesur\351e)g(est)f(de)f
(4,4)h(V)-11 b(.)-128 722 y
SDict begin H.S end
 -128 722 a -128 722 a
SDict begin 12 H.A end
 -128
722 a -128 722 a
SDict begin [/View [/XYZ H.V]/Dest (Item.3) cvn /DEST pdfmark end
 -128 722 a 0 TeXcolorgray -26 871 a
Ff(3.)p 0 TeXcolorgray 42 w Fh(J)n(e)17 b(calcule)h(60)12
b(\045)18 b(de)f(la)h(tension)h(maximale)g(:)1479 815
y(60)p 1459 852 122 5 v 1459 928 a(100)1601 871 y Fe(\243)10
b Fh(5)15 b Fe(\306)f Fh(0,)8 b(6)i Fe(\243)g Fh(5)16
b Fe(\306)e Fh(3.)80 1027 y(60)e(\045)18 b(de)g(la)f(tension)i
(maximale)g(corr)o(espond)e(\340)g(3)h(V)-11 b(.)80 1160
y(P)m(ar)17 b(lectur)o(e)h(gr)o(aphique)o(,)g(on)f(d\351ter)q(mine)i
(que)f(cette)g(tension)g(est)g(atteinte)h(au)f(bout)f(d)n('environ)h
(0,)8 b(09)19 b(s)o(.)85 1455 y

 85 1455 a 85 1455 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 12.3847 50.56694 -25.28346 -6.19235 pgfe

 gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore

 newpath

 restore

 save

 [1.0 0.0 0.0 1.0 -22.36137 -3.24039 ] concat

 pgfs



 0 setgray
 1
TeXcolorgray 101 1455 a Ff(Ex)o(er)o(cice)14 b(2)p 0
TeXcolorgray 85 1455 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 0 TeXcolorgray 0 TeXcolorgray
-128 1809 4156 4 v -128 1979 4 170 v -74 1920 a Fh(T)-8
b(emps)19 b(en)f(heur)o(e)p 525 1979 V 681 1930 a(0)p
875 1979 V 280 w(0,5)p 1225 1979 V 280 w(1)p 1575 1979
V 280 w(1,5)p 1925 1979 V 280 w(2)p 2275 1979 V 280 w(2,5)p
2625 1979 V 280 w(3)p 2974 1979 V 279 w(3,5)p 3324 1979
V 281 w(4)p 3674 1979 V 279 w(4,5)p 4024 1979 V -128
1982 4156 4 v -128 2152 4 170 v -68 2094 a(Distance)f(en)h(km)p
525 2152 V 681 2104 a(0)p 875 2152 V 290 w(15)p 1225
2152 V 265 w(.)10 b(.)g(.)p 1575 2152 V 275 w(55)p 1925
2152 V 270 w(70)p 2275 2152 V 270 w(80)p 2625 2152 V
249 w(100)p 2974 2152 V 230 w(110)p 3324 2152 V 230 w(135)p
3674 2152 V 230 w(160)p 4024 2152 V -128 2155 4156 4
v -128 2481 a
SDict begin H.S end
 -128 2481 a -128 2481 a
SDict begin 12 H.A end
 -128 2481 a -128
2481 a
SDict begin [/View [/XYZ H.V]/Dest (Item.4) cvn /DEST pdfmark end
 -128 2481 a 0 TeXcolorgray -26 2580 a Ff(1.)p
0 TeXcolorgray 42 w Fh(2)18 b(h)f(30)h(min)h(ou)e(2,5)i(h)e(:)h(la)f
(distance)h(par)o(cour)q(ue)f(est)h(\351gale)g(\340)f(80)h(km.)-128
2632 y
SDict begin H.S end
 -128 2632 a -128 2632 a
SDict begin 12 H.A end
 -128 2632 a -128 2632
a
SDict begin [/View [/XYZ H.V]/Dest (Item.5) cvn /DEST pdfmark end
 -128 2632 a 0 TeXcolorgray -26 2746 a Ff(2.)p 0 TeXcolorgray
42 w Fh(De)e(la)i(2)314 2722 y Fb(e)357 2746 y Fh(\340)f(la)h(3)533
2722 y Fb(e)576 2746 y Fh(heur)o(e)g(il)f(a)g(par)o(cour)q(u)g(100)10
b Fe(\241)g Fh(70)17 b Fe(\306)d Fh(30)19 b(km.)-128
2796 y
SDict begin H.S end
 -128 2796 a -128 2796 a
SDict begin 12 H.A end
 -128 2796 a -128 2796
a
SDict begin [/View [/XYZ H.V]/Dest (Item.6) cvn /DEST pdfmark end
 -128 2796 a 0 TeXcolorgray -26 2912 a Ff(3.)p 0 TeXcolorgray
42 w Fh(De)d(la)i(3)314 2888 y Fb(e)357 2912 y Fh(\340)f(la)h(4)533
2888 y Fb(e)576 2912 y Fh(heur)o(e)g(il)f(a)g(par)o(cour)q(u)g(135)10
b Fe(\241)g Fh(100)18 b Fe(\306)c Fh(35)k(km,)g(soit)g(plus)h(que)f
(pendant)g(la)f(3)2778 2888 y Fb(e)2821 2912 y Fh(heur)o(e)o(.)-128
2962 y
SDict begin H.S end
 -128 2962 a -128 2962 a
SDict begin 12 H.A end
 -128 2962 a -128 2962
a
SDict begin [/View [/XYZ H.V]/Dest (Item.7) cvn /DEST pdfmark end
 -128 2962 a -128 2962 a
SDict begin H.S end
 -128 2962 a -128 2962 a
SDict begin 12 H.A end
 -128
2962 a -128 2962 a
SDict begin [/View [/XYZ H.V]/Dest (Item.8) cvn /DEST pdfmark end
 -128 2962 a 0 TeXcolorgray -26 3078
a Ff(4.)p 0 TeXcolorgray 0 TeXcolorgray 88 w Fh(\()p
Ff(a)p Fh(\))p 0 TeXcolorgray 41 w(Placer)c(les)i(9)g(points)g(du)f
(tableau)h(dans)f(le)h(r)o(ep\350r)o(e)o(.)f(On)g(ne)g(peut)i(pas)e
(placer)h(le)g(point)g(d)n('abscisse)g(1)g(puisque)h(l)o('on)f(ne)g
(conna\356t)263 3178 y(pas)i(son)h(or)o(donn\351e)o(.)-128
3228 y
SDict begin H.S end
 -128 3228 a -128 3228 a
SDict begin 12 H.A end
 -128 3228 a -128 3228
a
SDict begin [/View [/XYZ H.V]/Dest (Item.9) cvn /DEST pdfmark end
 -128 3228 a 0 TeXcolorgray 121 3344 a Fh(\()p Ff(b)p
Fh(\))p 0 TeXcolorgray 42 w(En)f(utilisant)i(votr)o(e)e(r\350gle)o(,)h
(r)o(elier)f(les)h(points)h(cons\351cutifs)g(entr)o(e)e(eux.)-128
3396 y
SDict begin H.S end
 -128 3396 a -128 3396 a
SDict begin 12 H.A end
 -128 3396 a -128 3396
a
SDict begin [/View [/XYZ H.V]/Dest (Item.10) cvn /DEST pdfmark end
 -128 3396 a 0 TeXcolorgray -26 3510 a Ff(5.)p 0 TeXcolorgray
42 w Fh(On)g(lit)h(environ)g(2,25)h(h)f(soit)g(2)f(h)h(15)g(min.)-128
3554 y
SDict begin H.S end
 -128 3554 a -128 3554 a
SDict begin 12 H.A end
 -128 3554 a -128 3554
a
SDict begin [/View [/XYZ H.V]/Dest (Item.11) cvn /DEST pdfmark end
 -128 3554 a 0 TeXcolorgray -26 3676 a Ff(6.)p 0 TeXcolorgray
42 w Fh(S)o(i)h(la)g(vitesse)h(est)g(constante)g(pendant)f(cette)h
(heur)o(e)o(,)e(la)h(r)o(epr\351sentation)i(sur)e(cet)g(inter)q(valle)h
(est)g(af\002ne)9 b(;)18 b(on)h(tr)o(ace)g(donc)g(la)f(ver)q(ti-)80
3776 y(cale)g(\()r Fc(x)h Fe(\306)14 b Fh(1\))k(qui)f(coupe)i(la)e(r)o
(epr\351sentation)i(en)f(un)f(point)i(dont)e(l)o('or)o(donn\351e)h(est)
g(environ)g(35)g(\(km\).)-128 3826 y
SDict begin H.S end
 -128 3826 a -128
3826 a
SDict begin 12 H.A end
 -128 3826 a -128 3826 a
SDict begin [/View [/XYZ H.V]/Dest (Item.12) cvn /DEST pdfmark end
 -128 3826 a 0 TeXcolorgray
-26 3942 a Ff(7.)p 0 TeXcolorgray 42 w Fh(La)g(fonction)g(n)-6
b('est)18 b(pas)g(lin\351air)o(e)g(puisque)h(les)f(points)h(ne)f(sont)g
(pas)g(align\351s)o(.)80 4075 y(Plus)i(math\351matique)j(on)e(a)f(vu)h
(qu)n('il)g(faisait)g(30)g(km)g(en)f(une)h(heur)o(e)f(et)h(plus)g(tar)o
(d)f(35)h(km)f(en)h(une)g(heur)o(e)o(.)f(La)g(fonction)i(n)-6
b('est)21 b(pas)80 4174 y(lin\351air)o(e)o(.)85 4570
y

 85 4570 a 85 4570 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 save

 /pgffc{0.38 0.56 0.68 setrgbcolor}def

 12.3847 50.56694 -25.28346 -6.19235 pgfe

 gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore

 newpath

 restore

 save

 [1.0 0.0 0.0 1.0 -22.36137 -3.24039 ] concat

 pgfs



 0 setgray
 1 TeXcolorgray 101 4570 a Ff(Ex)o(er)o(cice)14
b(3)p 0 TeXcolorgray 85 4570 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -128 4936 a Fh(Chaque)19
b(jour)f(l)o('arrosage)g(fonctionne)i(pendant)e(2)10
b Fe(\243)g Fh(15)17 b Fe(\306)e Fh(30)j(min)h(soit)f(0,5)h(h.)f(U)m(n)
h(arroseur)e(d\351bite)h(donc)f(pendant)i(cette)g(demi-heur)o(e)-128
5035 y(0,2)g(m)61 5001 y Fa(3)96 5035 y Fh(.)-128 5156
y(P)n(endant)f(le)g(mois)g(de)f(juillet)i(on)f(aur)o(a)f(donc)g
(d\351vers\351)h(:)-128 5277 y(31)10 b Fe(\243)g Fh(12)g
Fe(\243)g Fh(4)g Fe(\243)g Fh(0,)e(2)19 b Fe(\306)c Fh(297,)8
b(6)19 b(m)771 5243 y Fa(3)807 5277 y Fh(,)e(soit)h(297)12
b(600)21 b(litr)o(es)c(d)n('eau.)p 0 TeXcolorgray 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray -128 5646 a Ff(Ex)o(er)o(cice)d(2)i
(question)f(4)p 0 TeXcolorgray 3987 5856 a Fh(1)p 0 TeXcolorgray
eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 -354 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 -354
a 0 TeXcolorgray -136 -1330 a
SDict begin H.S end
 -136 -1330 a -136 -1330
a
SDict begin H.R end
 -136 -1330 a -136 -1330 a
SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
 -136 -1330 a 0 TeXcolorgray
0 TeXcolorgray 0 TeXcolorgray 946 4007 a
tx@Dict begin  gsave STV CP T /ps@refangle 90  def grestore  end
 946 4007 a 946
4007 a
tx@Dict begin  { 241.84792 0.0 } PutCoor PutBegin  end
 946 4007 a 746 3948 a Fh(T)-8 b(emps)19 b(en)f
Fc(h)946 4007 y
tx@Dict begin  PutEnd  end
 946 4007 a 946 4007 a
tx@Dict begin  gsave STV CP T /ps@refangle 0  def grestore  end
 946 4007 a 946
4007 a
tx@Dict begin  { 0.0 547.74791 } PutCoor PutBegin  end
 946 4007 a 988 4035 a Fh(Distance)f(en)h(km)946
4007 y
tx@Dict begin  PutEnd  end
 946 4007 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 0.0 540.63431 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 24.18478 540.63431 24.18478 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 48.36958 540.63431 48.36958 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 72.55437 540.63431 72.55437 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 96.73917 540.63431 96.73917 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 120.92395 540.63431 120.92395 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 145.10875 540.63431 145.10875 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 169.29353 540.63431 169.29353 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 193.47833 540.63431 193.47833 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 217.66312 540.63431 217.66312 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 241.84792 540.63431 241.84792 0.0 
 /Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 540.63431 266.0327 0.0   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 0.0 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 14.22722 0.0 14.22722   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 28.45444 0.0 28.45444   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 42.68166 0.0 42.68166   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 56.90887 0.0 56.90887   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 71.1361 0.0 71.1361   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 85.36331 0.0 85.36331   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 99.59053 0.0 99.59053   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 113.81775 0.0 113.81775  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 128.04497 0.0 128.04497  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 142.27219 0.0 142.27219  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 156.4994 0.0 156.4994   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 170.72662 0.0 170.72662  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 184.95384 0.0 184.95384  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 199.18106 0.0 199.18106  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 213.40828 0.0 213.40828  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 227.6355 0.0 227.6355   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 241.86272 0.0 241.86272  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 256.08994 0.0 256.08994  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 270.31715 0.0 270.31715  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 284.54437 0.0 284.54437  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 298.77159 0.0 298.77159  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 312.99881 0.0 312.99881  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 327.22603 0.0 327.22603  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 341.45325 0.0 341.45325  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 355.68047 0.0 355.68047  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 369.90768 0.0 369.90768  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 384.1349 0.0 384.1349   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 398.36212 0.0 398.36212  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 412.58934 0.0 412.58934  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 426.81656 0.0 426.81656  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 441.04378 0.0 441.04378  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 455.271 0.0 455.271   /Lineto
/lineto load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq {
0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul
exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2
ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 0.2 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 469.49821 0.0 469.49821  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 483.72543 0.0 483.72543  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 497.95265 0.0 497.95265  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 512.17987 0.0 512.17987  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 526.40709 0.0 526.40709  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.2 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 540.63431 0.0 540.63431  
/Lineto /lineto load def 0  setlinejoin false  NArray n 0 eq not {
n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul add dup
1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy /y1 ED /x1
ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha
cos arrowlength mul add y1 Alpha sin arrowlength mul add /n n 1 sub
def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha
y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs
def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha cos ArrowPos
mul add y1 Alpha sin ArrowPos mul add ArrowInside pop pop } repeat
}{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 }
ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x2 x1 sub
ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop
} repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2 sub def
n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop } if   gsave
0.2 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 1.25 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 266.0327  0 0.0  0 ArrowA CP 4 2 roll
ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq false and exch 2 lt true and or { /viceversa 0.0
 266.0327  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
0.0  def /maxTickline 540.63431  def /dT 3169949 abs 65536 div viceversa
{ neg } if def /DT 1 abs viceversa { neg } if def /subTNo 1 def subTNo
0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse -4.0 4.0 /tickend
exch def /tickstart exch def /Twidth 0.4  def /subTwidth 0.2  def /STsize
0.75 def /TColor { 0  setgray  } def /subTColor { 0.5  setgray  } def
/MinValue { xStart } def /MaxValue { xEnd 2.0 5.  CLW mul add 1.4 
mul viceversa { add epsilon sub }{ sub epsilon add } ifelse } def /logLines
{ false } def /LSstroke {  0  setlinejoin 0  setlinecap stroke stroke}
def /subLSstroke {  0  setlinejoin 0  setlinecap stroke stroke} def
0 dT MaxValue 1 add { /cntTick exch def logLines { gsave 1 1 DT { 1
sub /OffSet exch def -10 subTNo 1 add div dup 10 add exch dup -0.1
mul 1 add { /dx exch def /x dx log OffSet add 48.36958  mul cntTick
add def x abs MaxValue abs le { false { x minTickline  moveto x maxTickline
 lineto } { x tickstart STsize mul  moveto x tickend STsize mul  lineto
} ifelse } if } for } for subTwidth SLW subTColor subLSstroke grestore
stroke /dsubT 0 def } if dsubT abs 0 gt { gsave /cntsubTick cntTick
dsubT add def subTNo 1 sub { cntsubTick abs MaxValue abs le { false
{ cntsubTick minTickline STsize mul  moveto cntsubTick maxTickline
STsize mul  lineto } { cntsubTick tickstart STsize mul  moveto cntsubTick
tickend STsize mul  lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline  moveto cntTick
maxTickline  lineto } { cntTick tickstart  moveto cntTick tickend 
lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 48.36958  mul cntTick add def x abs MinValue
abs le { false { x minTickline  moveto x maxTickline  lineto } { x
tickstart STsize mul  moveto x tickend STsize mul  lineto } ifelse
} if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke grestore
} dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1
sub { cntsubTick abs MinValue abs le { cntsubTick tickstart STsize
mul  moveto cntsubTick tickend STsize mul  lineto }{ exit } ifelse
/cntsubTick cntsubTick dsubT add def } repeat subTwidth SLW subTColor
subLSstroke grestore } if showOrigin { gsave cntTick tickstart  moveto
cntTick tickend  lineto Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.25
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 540.63431
0.0 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.25 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.25
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 266.0327
0.0 0.0 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.25 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 1.25 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def /ArrowInside
{ } def   /showOrigin true def 0 540.63431  0 0.0  ArrowA CP 4 2 roll
ArrowB 2 copy /yEnd exch def /xEnd exch def gsave L  0  setlinejoin
0  setlinecap stroke  stroke grestore /yStart exch def /xStart exch
def 0 dup 2 mod 0 eq true and exch 2 lt false and or { /viceversa 0.0
 540.63431  gt { true }{ false } ifelse def /epsilon 0.01 def /minTickline
0.0  def /maxTickline 266.0327  def /dT 3729580 abs 65536 div viceversa
{ neg } if def /DT 20 abs viceversa { neg } if def /subTNo 1 def subTNo
0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse -4.0 4.0 /tickend
exch def /tickstart exch def /Twidth 0.4  def /subTwidth 0.2  def /STsize
0.75 def /TColor { 0  setgray  } def /subTColor { 0.5  setgray  } def
/MinValue { yStart } def /MaxValue { yEnd 2.0 5.  CLW mul add 1.4 
mul viceversa { add epsilon sub }{ sub epsilon add } ifelse } def /logLines
{ false } def /LSstroke {  0  setlinejoin 0  setlinecap stroke  stroke}
def /subLSstroke {  0  setlinejoin 0  setlinecap stroke  stroke} def
0 dT MaxValue 1 add { /cntTick exch def logLines { gsave 1 1 DT { 1
sub /OffSet exch def -10 subTNo 1 add div dup 10 add exch dup -0.1
mul 1 add { /dx exch def /x dx log OffSet add 2.84544  mul cntTick
add def x abs MaxValue abs le { false { x minTickline exch moveto x
maxTickline exch lineto } { x tickstart STsize mul exch moveto x tickend
STsize mul exch lineto } ifelse } if } for } for subTwidth SLW subTColor
subLSstroke grestore stroke /dsubT 0 def } if dsubT abs 0 gt { gsave
/cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick abs MaxValue
abs le { false { cntsubTick minTickline STsize mul exch moveto cntsubTick
maxTickline STsize mul exch lineto } { cntsubTick tickstart STsize
mul exch moveto cntsubTick tickend STsize mul exch lineto } ifelse
}{ exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline exch moveto cntTick maxTickline exch lineto } {
cntTick tickstart exch moveto cntTick tickend exch lineto } ifelse
Twidth SLW TColor LSstroke grestore }{ /showOrigin true def } ifelse
} for /showOrigin true def /dT dT neg def /dsubT dsubT neg def 0 dT
MinValue epsilon viceversa { add }{ sub } ifelse { /cntTick exch def
logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 2.84544  mul cntTick add def x abs MinValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for /dsubT 0 def subTwidth SLW subTColor subLSstroke grestore } dsubT
abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MinValue abs le { cntsubTick tickstart STsize mul exch moveto cntsubTick
tickend STsize mul exch lineto }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave cntTick tickstart exch moveto cntTick tickend
exch lineto Twidth SLW TColor LSstroke grestore }{ /showOrigin true
def } ifelse } for } if  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.25
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 0.0 540.63431
0.0 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray n 0
eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW mul
add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.25 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  1.25
SLW 0  setgray  /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.
 scale  false 0.4 1.4 2.0 5. CLW mul add dup 2 div /w ED mul dup /h
ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0 0 L w h
L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore grestore
0 h a sub moveto   EndArrow  } def /ArrowInside { } def  [ 266.0327
0.0 0.0 0.0   /Lineto /lineto load def 0  setlinejoin false  NArray
n 0 eq not { n 1 eq { 0 0 /n 2 def } if () length 0 gt { 2.0 5.  CLW
mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength exch def 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1 sub Atan def ArrowA
x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength mul add /n
n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt
{ /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.25 SLW 0  setgray  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore end
 
@endspecial 831 4032 a Fh(0)790 3559 y(20)790
3087 y(40)790 2615 y(60)790 2142 y(80)750 1670 y(100)750
1197 y(120)750 725 y(140)750 252 y(160)750 -220 y(180)926
4132 y(0)361 b(1)h(2)g(3)f(4)h(5)946 4007 y @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.25 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { } def /ArrowInside { } def   /showOrigin true def 266.0327
 0 0.0  0 ArrowA CP 4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch
def gsave L  0  setlinejoin 0  setlinecap stroke  stroke grestore /yStart
exch def /xStart exch def 0 dup 2 mod 0 eq false and exch 2 lt true
and or { /viceversa 0.0  266.0327  gt { true }{ false } ifelse def
/epsilon 0.01 def /minTickline 0.0  def /maxTickline 540.63431  def
/dT 3169949 abs 65536 div viceversa { neg } if def /DT 1 abs viceversa
{ neg } if def /subTNo 1 def subTNo 0 gt { /dsubT dT subTNo div def}{
/dsubT 0 def } ifelse -4.0 4.0 /tickend exch def /tickstart exch def
/Twidth 0.4  def /subTwidth 0.2  def /STsize 0.75 def /TColor { 0 
setgray  } def /subTColor { 0.5  setgray  } def /MinValue { xStart
} def /MaxValue { xEnd } def /logLines { false } def /LSstroke {  0
 setlinejoin 0  setlinecap stroke stroke} def /subLSstroke {  0  setlinejoin
0  setlinecap stroke stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 48.36958  mul cntTick add def x abs MaxValue abs le { false { x
minTickline  moveto x maxTickline  lineto } { x tickstart STsize mul
 moveto x tickend STsize mul  lineto } ifelse } if } for } for subTwidth
SLW subTColor subLSstroke grestore stroke /dsubT 0 def } if dsubT abs
0 gt { gsave /cntsubTick cntTick dsubT add def subTNo 1 sub { cntsubTick
abs MaxValue abs le { false { cntsubTick minTickline STsize mul  moveto
cntsubTick maxTickline STsize mul  lineto } { cntsubTick tickstart
STsize mul  moveto cntsubTick tickend STsize mul  lineto } ifelse }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave false {
cntTick minTickline  moveto cntTick maxTickline  lineto } { cntTick
tickstart  moveto cntTick tickend  lineto } ifelse Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for /showOrigin
true def /dT dT neg def /dsubT dsubT neg def 0 dT MinValue epsilon
viceversa { add }{ sub } ifelse { /cntTick exch def logLines { gsave
1 1 DT cvi { 1 sub /OffSet exch def -10 subTNo 1 add div dup 10 add
exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet add 48.36958
 mul cntTick add def x abs MinValue abs le { false { x minTickline
 moveto x maxTickline  lineto } { x tickstart STsize mul  moveto x
tickend STsize mul  lineto } ifelse } if } for } for /dsubT 0 def subTwidth
SLW subTColor subLSstroke grestore } dsubT abs 0 gt { gsave /cntsubTick
cntTick dsubT add def subTNo 1 sub { cntsubTick abs MinValue abs le
{ cntsubTick tickstart STsize mul  moveto cntsubTick tickend STsize
mul  lineto }{ exit } ifelse /cntsubTick cntsubTick dsubT add def }
repeat subTwidth SLW subTColor subLSstroke grestore } if showOrigin
{ gsave cntTick tickstart  moveto cntTick tickend  lineto Twidth SLW
TColor LSstroke grestore }{ /showOrigin true def } ifelse } for } if
 end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 0.0 540.63431 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 0.0 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 1.25 SLW 0  setgray  /ArrowA { moveto }
def /ArrowB { } def /ArrowInside { } def   /showOrigin true def 0 540.63431
 0 0.0  ArrowA CP 4 2 roll ArrowB 2 copy /yEnd exch def /xEnd exch
def gsave L  0  setlinejoin 0  setlinecap stroke  stroke grestore /yStart
exch def /xStart exch def 0 dup 2 mod 0 eq true and exch 2 lt false
and or { /viceversa 0.0  540.63431  gt { true }{ false } ifelse def
/epsilon 0.01 def /minTickline 0.0  def /maxTickline 266.0327  def
/dT 3729580 abs 65536 div viceversa { neg } if def /DT 20 abs viceversa
{ neg } if def /subTNo 1 def subTNo 0 gt { /dsubT dT subTNo div def}{
/dsubT 0 def } ifelse -4.0 4.0 /tickend exch def /tickstart exch def
/Twidth 0.4  def /subTwidth 0.2  def /STsize 0.75 def /TColor { 0 
setgray  } def /subTColor { 0.5  setgray  } def /MinValue { yStart
} def /MaxValue { yEnd } def /logLines { false } def /LSstroke {  0
 setlinejoin 0  setlinecap stroke  stroke} def /subLSstroke {  0  setlinejoin
0  setlinecap stroke  stroke} def 0 dT MaxValue 1 add { /cntTick exch
def logLines { gsave 1 1 DT { 1 sub /OffSet exch def -10 subTNo 1 add
div dup 10 add exch dup -0.1 mul 1 add { /dx exch def /x dx log OffSet
add 2.84544  mul cntTick add def x abs MaxValue abs le { false { x
minTickline exch moveto x maxTickline exch lineto } { x tickstart STsize
mul exch moveto x tickend STsize mul exch lineto } ifelse } if } for
} for subTwidth SLW subTColor subLSstroke grestore stroke /dsubT 0
def } if dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def subTNo
1 sub { cntsubTick abs MaxValue abs le { false { cntsubTick minTickline
STsize mul exch moveto cntsubTick maxTickline STsize mul exch lineto
} { cntsubTick tickstart STsize mul exch moveto cntsubTick tickend
STsize mul exch lineto } ifelse }{ exit } ifelse /cntsubTick cntsubTick
dsubT add def } repeat subTwidth SLW subTColor subLSstroke grestore
} if showOrigin { gsave false { cntTick minTickline exch moveto cntTick
maxTickline exch lineto } { cntTick tickstart exch moveto cntTick tickend
exch lineto } ifelse Twidth SLW TColor LSstroke grestore }{ /showOrigin
true def } ifelse } for /showOrigin true def /dT dT neg def /dsubT
dsubT neg def 0 dT MinValue epsilon viceversa { add }{ sub } ifelse
{ /cntTick exch def logLines { gsave 1 1 DT cvi { 1 sub /OffSet exch
def -10 subTNo 1 add div dup 10 add exch dup -0.1 mul 1 add { /dx exch
def /x dx log OffSet add 2.84544  mul cntTick add def x abs MinValue
abs le { false { x minTickline exch moveto x maxTickline exch lineto
} { x tickstart STsize mul exch moveto x tickend STsize mul exch lineto
} ifelse } if } for } for /dsubT 0 def subTwidth SLW subTColor subLSstroke
grestore } dsubT abs 0 gt { gsave /cntsubTick cntTick dsubT add def
subTNo 1 sub { cntsubTick abs MinValue abs le { cntsubTick tickstart
STsize mul exch moveto cntsubTick tickend STsize mul exch lineto }{
exit } ifelse /cntsubTick cntsubTick dsubT add def } repeat subTwidth
SLW subTColor subLSstroke grestore } if showOrigin { gsave cntTick
tickstart exch moveto cntTick tickend exch lineto Twidth SLW TColor
LSstroke grestore }{ /showOrigin true def } ifelse } for } if  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 0.0 540.63431 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.25 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 266.0327 0.0 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.25 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 831 4032 a(0)790
3559 y(20)790 3087 y(40)790 2615 y(60)790 2142 y(80)750
1670 y(100)750 1197 y(120)750 725 y(140)750 252 y(160)750
-220 y(180)926 4132 y(0)f(1)h(2)g(3)f(4)h(5)946 4007
y @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW 0  setgray  [ 217.66312 455.271
193.47833 384.1349 169.29353 312.99881 145.10875 284.54437 120.92395
227.6355 96.73917 199.18106 72.55437 156.4994 24.18478 42.68166 0.0
0.0   false NArray  /DS 2.0 2. CLW mul add 2 div def /PSTricksDotFont
0. [1.0 0.0 0.0 1.0 0.0 0.0] FontDot /Dot { moveto gsave 1.  1.  scale
(b) show grestore } bind def   1. .setopacityalpha  newpath n { transform
floor .5 add exch floor .5 add exch itransform Dot } repeat  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  1.0 SLW 0  setgray  /ArrowA { moveto } def /ArrowB
{ } def /ArrowInside { } def  [ 217.66312 455.271 193.47833 384.1349
169.29353 312.99881 145.10875 284.54437 120.92395 227.6355 96.73917
199.18106 72.55437 156.4994 24.18478 42.68166 0.0 0.0   /Lineto /lineto
load def 0  setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n
2 def } if () length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4
mul neg add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED
/Alpha y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength
mul add y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy
/y1 ED /x1 ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1
sub Atan def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin
ArrowPos mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def
/dArrowPos 1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi {
/ArrowPos ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add
y2 y1 sub ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse
pop pop Lineto } repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat
} ifelse CP 4 2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0  setgray
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def  1.0 SLW
0 0 1  setrgbcolor  /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2
div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg
h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def  [ 108.83156
0.0 108.83156 213.40828 0.0 213.40828   /Lineto /lineto load def 0
 setlinejoin false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
(>) length 0 gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4 mul neg
add /arrowlength exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha
y2 y1 sub x2 x1 sub Atan def ArrowA x1 Alpha cos arrowlength mul add
y1 Alpha sin arrowlength mul add /n n 1 sub def n { 4 copy /y1 ED /x1
ED /y2 ED /x2 ED x1 y1 0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan
def /ArrowPos 0.  def /dArrowPos 0.5  abs def 1.  cvi { /ArrowPos ArrowPos
dArrowPos add def x1 Alpha cos ArrowPos mul add y1 Alpha sin ArrowPos
mul add ArrowInside pop pop } repeat }{ /ArrowPos 0.  def /dArrowPos
1. 1 gt {1.0 1. 1.0 add div }{0.5 } ifelse def 1.  cvi { /ArrowPos
ArrowPos dArrowPos add def x2 x1 sub ArrowPos mul x1 add y2 y1 sub
ArrowPos mul y1 add ArrowInside pop pop } repeat } ifelse pop pop Lineto
} repeat }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse CP 4
2 roll ArrowB L pop pop } if   gsave 1.0 SLW 0 0 1  setrgbcolor  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul
add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if
gsave w neg h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def  1.0 SLW
0.78 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { } def /ArrowInside
{ BeginArrow 1.  1.  scale  false 0.4 1.4 2.0 5. CLW mul add dup 2
div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg
h moveto 0 0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha
 fill grestore grestore 0 h a sub moveto   EndArrow  } def  [ 0.0 99.59053
48.36958 99.59053 48.36958 0.0   /Lineto /lineto load def 0  setlinejoin
false  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if (>) length 0
gt { 2.0 5.  CLW mul add dup 1.4  mul exch 0.4 mul neg add /arrowlength
exch def 4 copy /y1 ED /x1 ED /y2 ED /x2 ED /Alpha y2 y1 sub x2 x1
sub Atan def ArrowA x1 Alpha cos arrowlength mul add y1 Alpha sin arrowlength
mul add /n n 1 sub def n { 4 copy /y1 ED /x1 ED /y2 ED /x2 ED x1 y1
0.5  1 gt { /Alpha y2 y1 sub x2 x1 sub Atan def /ArrowPos 0.  def /dArrowPos
0.5  abs def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def x1 Alpha
cos ArrowPos mul add y1 Alpha sin ArrowPos mul add ArrowInside pop
pop } repeat }{ /ArrowPos 0.  def /dArrowPos 1. 1 gt {1.0 1. 1.0 add
div }{0.5 } ifelse def 1.  cvi { /ArrowPos ArrowPos dArrowPos add def
x2 x1 sub ArrowPos mul x1 add y2 y1 sub ArrowPos mul y1 add ArrowInside
pop pop } repeat } ifelse pop pop Lineto } repeat }{ ArrowA /n n 2
sub def n { Lineto } repeat } ifelse CP 4 2 roll ArrowB L pop pop }
if   gsave 1.0 SLW 0.78 0 0  setrgbcolor  1. .setopacityalpha   0 
setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial 0 TeXcolorgray
-128 5856 a(2)p 0.5 0 0.5 TeXcolorrgb 0 TeXcolorgray
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
